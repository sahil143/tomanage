{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.populateParams = populateParams;\nexports.safelyDecodeURIComponent = safelyDecodeURIComponent;\nexports.getUrlWithReactNavigationConcessions = getUrlWithReactNavigationConcessions;\nexports.createConfig = createConfig;\nexports.assertScreens = assertScreens;\nexports.configRegExp = configRegExp;\nexports.isDynamicPart = isDynamicPart;\nexports.replacePart = replacePart;\nexports.getParamValue = getParamValue;\nexports.handleUrlParams = handleUrlParams;\nexports.spreadParamsAcrossAllStates = spreadParamsAcrossAllStates;\nexports.stripBaseUrl = stripBaseUrl;\nexports.matchForEmptyPath = matchForEmptyPath;\nexports.appendIsInitial = appendIsInitial;\nexports.getRouteConfigSorter = getRouteConfigSorter;\nexports.parseQueryParams = parseQueryParams;\nexports.cleanPath = cleanPath;\nexports.routePatternToRegex = routePatternToRegex;\nconst escape_string_regexp_1 = __importDefault(require(\"escape-string-regexp\"));\nconst matchers_1 = require(\"../matchers\");\nfunction populateParams(routes, params) {\n  if (!routes || !params || Object.keys(params).length === 0) return;\n  for (const route of routes) {\n    Object.assign(route, {\n      params\n    });\n  }\n  return routes;\n}\nfunction safelyDecodeURIComponent(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch {\n    return str;\n  }\n}\nfunction getUrlWithReactNavigationConcessions(path, baseUrl = \"\") {\n  const pathWithoutGroups = (0, matchers_1.stripGroupSegmentsFromPath)(stripBaseUrl(path, baseUrl));\n  let pathname = '';\n  let hash = '';\n  try {\n    const parsed = new URL(path, 'file:');\n    pathname = parsed.pathname;\n    hash = parsed.hash;\n  } catch {}\n  const withoutBaseUrl = stripBaseUrl(pathname, baseUrl);\n  return {\n    path,\n    nonstandardPathname: withoutBaseUrl.replace(/^\\/+/g, '').replace(/\\/+$/g, '') + '/',\n    hash,\n    pathWithoutGroups\n  };\n}\nfunction createConfig(screen, pattern, routeNames, config = {}) {\n  const parts = [];\n  let isDynamic = false;\n  const isIndex = screen === 'index' || screen.endsWith('/index');\n  let staticPartCount = 0;\n  for (const part of pattern.split('/')) {\n    if (part) {\n      const isDynamicPart = part.startsWith(':') || part.startsWith('*') || part.includes('*not-found');\n      isDynamic ||= isDynamicPart;\n      if (!(0, matchers_1.matchGroupName)(part)) {\n        parts.push(part);\n        if (!isDynamicPart) {\n          staticPartCount++;\n        }\n      }\n    }\n  }\n  const hasChildren = config.screens ? !!Object.keys(config.screens)?.length : false;\n  const type = hasChildren ? 'layout' : isDynamic ? 'dynamic' : 'static';\n  if (isIndex) {\n    parts.push('index');\n    staticPartCount++;\n  }\n  return {\n    type,\n    isIndex,\n    hasChildren,\n    parts,\n    staticPartCount,\n    userReadableName: [...routeNames.slice(0, -1), config.path || screen].join('/'),\n    expandedRouteNames: routeNames.slice(1).flatMap(name => {\n      return name.split('/');\n    })\n  };\n}\nfunction assertScreens(options) {\n  if (!options?.screens) {\n    throw Error(\"You must pass a 'screens' object to 'getStateFromPath' to generate a path.\");\n  }\n}\nfunction configRegExp(config) {\n  return config.pattern ? new RegExp(`^(${config.pattern.split('/').map(formatRegexPattern).join('')})$`) : undefined;\n}\nfunction isDynamicPart(p) {\n  return p.length > 1 && (p.startsWith(':') || p.startsWith('*'));\n}\nfunction replacePart(p) {\n  return p.replace(/^[:*]/, '').replace(/\\?$/, '');\n}\nfunction getParamValue(p, value) {\n  if (p.startsWith('*')) {\n    const values = value.split('/').filter(v => v !== '');\n    return values.length === 0 && p.endsWith('?') ? undefined : values;\n  } else {\n    return value;\n  }\n}\nfunction formatRegexPattern(it) {\n  it = it.replace(' ', '%20');\n  if (it.startsWith(':')) {\n    return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  } else if (it.startsWith('*')) {\n    return `((.*\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  }\n  if ((0, matchers_1.matchGroupName)(it) != null) {\n    return `(?:${(0, escape_string_regexp_1.default)(it)}\\\\/)?`;\n  }\n  return (0, escape_string_regexp_1.default)(it) + `\\\\/`;\n}\nfunction handleUrlParams(route, params) {\n  if (params) {\n    route.params = Object.assign(Object.create(null), route.params);\n    for (const [name, value] of Object.entries(params)) {\n      if (route.params?.[name]) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(`Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`);\n        }\n      }\n      if (!route.params?.[name]) {\n        route.params[name] = value;\n        continue;\n      }\n    }\n    if (Object.keys(route.params).length === 0) {\n      delete route.params;\n    }\n  }\n}\nfunction spreadParamsAcrossAllStates(state, params) {\n  while (state) {\n    const route = state.routes[0];\n    route.params = Object.assign({}, route.params, params);\n  }\n}\nfunction stripBaseUrl(path, baseUrl = \"\") {\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      return path.replace(/^\\/+/g, '/').replace(new RegExp(`^\\\\/?${(0, escape_string_regexp_1.default)(baseUrl)}`, 'g'), '');\n    }\n  }\n  return path;\n}\nfunction matchForEmptyPath(configs) {\n  const leafNodes = configs.filter(config => !config.hasChildren).map(value => {\n    return Object.assign({}, value, {\n      path: (0, matchers_1.stripGroupSegmentsFromPath)(value.path)\n    });\n  });\n  const match = leafNodes.find(config => config.path === '' && (!config.regex || config.regex.test(''))) ?? leafNodes.find(config => config.path.startsWith(':') && config.regex.test('')) ?? leafNodes.find(config => config.path.startsWith('*') && config.regex.test('/'));\n  return match;\n}\nfunction appendIsInitial(initialRoutes) {\n  const resolvedInitialPatterns = initialRoutes.map(route => joinPaths(...route.parentScreens, route.initialRouteName));\n  return function (config) {\n    config.isInitial = resolvedInitialPatterns.includes(config.routeNames.join('/'));\n    return config;\n  };\n}\nconst joinPaths = (...paths) => [].concat(...paths.map(p => p.split('/'))).filter(Boolean).join('/');\nfunction getRouteConfigSorter(previousSegments = []) {\n  return function sortConfigs(a, b) {\n    if (a.pattern === b.pattern) {\n      return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));\n    }\n    if (a.pattern.startsWith(b.pattern) && !b.isIndex) {\n      return -1;\n    }\n    if (b.pattern.startsWith(a.pattern) && !a.isIndex) {\n      return 1;\n    }\n    if (a.type === 'static' && b.type !== 'static') {\n      return -1;\n    } else if (a.type !== 'static' && b.type === 'static') {\n      return 1;\n    }\n    if (a.staticPartCount !== b.staticPartCount) {\n      return b.staticPartCount - a.staticPartCount;\n    }\n    const similarToPreviousA = previousSegments.filter((value, index) => {\n      return value === a.expandedRouteNames[index] && value.startsWith('(') && value.endsWith(')');\n    });\n    const similarToPreviousB = previousSegments.filter((value, index) => {\n      return value === b.expandedRouteNames[index] && value.startsWith('(') && value.endsWith(')');\n    });\n    if ((similarToPreviousA.length > 0 || similarToPreviousB.length > 0) && similarToPreviousA.length !== similarToPreviousB.length) {\n      return similarToPreviousB.length - similarToPreviousA.length;\n    }\n    for (let i = 0; i < Math.max(a.parts.length, b.parts.length); i++) {\n      if (a.parts[i] == null) {\n        return 1;\n      }\n      if (b.parts[i] == null) {\n        return -1;\n      }\n      const aWildCard = a.parts[i].startsWith('*');\n      const bWildCard = b.parts[i].startsWith('*');\n      if (aWildCard && bWildCard) {\n        const aNotFound = a.parts[i].match(/^[*]not-found$/);\n        const bNotFound = b.parts[i].match(/^[*]not-found$/);\n        if (aNotFound && bNotFound) {\n          continue;\n        } else if (aNotFound) {\n          return 1;\n        } else if (bNotFound) {\n          return -1;\n        }\n        continue;\n      }\n      if (aWildCard) {\n        return 1;\n      }\n      if (bWildCard) {\n        return -1;\n      }\n      const aSlug = a.parts[i].startsWith(':');\n      const bSlug = b.parts[i].startsWith(':');\n      if (aSlug && bSlug) {\n        const aNotFound = a.parts[i].match(/^[*]not-found$/);\n        const bNotFound = b.parts[i].match(/^[*]not-found$/);\n        if (aNotFound && bNotFound) {\n          continue;\n        } else if (aNotFound) {\n          return 1;\n        } else if (bNotFound) {\n          return -1;\n        }\n        continue;\n      }\n      if (aSlug) {\n        return 1;\n      }\n      if (bSlug) {\n        return -1;\n      }\n    }\n    if (a.isInitial && !b.isInitial) {\n      return -1;\n    } else if (!a.isInitial && b.isInitial) {\n      return 1;\n    }\n    return b.parts.length - a.parts.length;\n  };\n}\nfunction parseQueryParams(path, route, parseConfig, hash) {\n  const searchParams = new URL(path, 'https://phony.example').searchParams;\n  const params = Object.create(null);\n  if (hash) {\n    params['#'] = hash.slice(1);\n  }\n  for (const name of searchParams.keys()) {\n    if (route.params?.[name]) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(`Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`);\n      }\n    } else {\n      const values = parseConfig?.hasOwnProperty(name) ? searchParams.getAll(name).map(value => parseConfig[name](value)) : searchParams.getAll(name);\n      params[name] = values.length === 1 ? values[0] : values;\n    }\n  }\n  return Object.keys(params).length ? params : undefined;\n}\nfunction cleanPath(path) {\n  path = path.replace(/\\/+/g, '/').replace(/^\\//, '').replace(/\\?.*$/, '');\n  return path.endsWith('/') ? path : `${path}/`;\n}\nfunction routePatternToRegex(pattern) {\n  return new RegExp(`^(${pattern.split('/').map(it => {\n    if (it.startsWith('(') && it.endsWith(')')) {\n      return `${it}?`;\n    } else if (it.startsWith(':')) {\n      return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n    }\n    return `${it === '*' ? '.*' : (0, escape_string_regexp_1.default)(it)}\\\\/`;\n  }).join('')})`);\n}","map":{"version":3,"names":["exports","populateParams","safelyDecodeURIComponent","getUrlWithReactNavigationConcessions","createConfig","assertScreens","configRegExp","isDynamicPart","replacePart","getParamValue","handleUrlParams","spreadParamsAcrossAllStates","stripBaseUrl","matchForEmptyPath","appendIsInitial","getRouteConfigSorter","parseQueryParams","cleanPath","routePatternToRegex","escape_string_regexp_1","__importDefault","require","matchers_1","routes","params","Object","keys","length","route","assign","str","decodeURIComponent","path","baseUrl","pathWithoutGroups","stripGroupSegmentsFromPath","pathname","hash","parsed","URL","withoutBaseUrl","nonstandardPathname","replace","screen","pattern","routeNames","config","parts","isDynamic","isIndex","endsWith","staticPartCount","part","split","startsWith","includes","matchGroupName","push","hasChildren","screens","type","userReadableName","slice","join","expandedRouteNames","flatMap","name","options","Error","RegExp","map","formatRegexPattern","undefined","p","value","values","filter","v","it","default","create","entries","process","env","NODE_ENV","console","warn","state","configs","leafNodes","match","find","regex","test","initialRoutes","resolvedInitialPatterns","joinPaths","parentScreens","initialRouteName","isInitial","paths","concat","Boolean","previousSegments","sortConfigs","a","b","localeCompare","similarToPreviousA","index","similarToPreviousB","i","Math","max","aWildCard","bWildCard","aNotFound","bNotFound","aSlug","bSlug","parseConfig","searchParams","hasOwnProperty","getAll"],"sources":["/Users/sbudhwar/workspace/github/tomanage/node_modules/expo-router/src/fork/getStateFromPath-forks.ts"],"sourcesContent":["import { InitialState } from '@react-navigation/native';\nimport escape from 'escape-string-regexp';\nimport * as queryString from 'query-string';\n\nimport type { InitialRouteConfig, Options, ParsedRoute, RouteConfig } from './getStateFromPath';\nimport { matchGroupName, stripGroupSegmentsFromPath } from '../matchers';\n\nexport type ExpoOptions = {\n  previousSegments?: string[];\n};\n\nexport type ExpoRouteConfig = {\n  type: 'static' | 'dynamic' | 'layout';\n  userReadableName: string;\n  isIndex: boolean;\n  isInitial?: boolean;\n  hasChildren: boolean;\n  expandedRouteNames: string[];\n  parts: string[];\n  staticPartCount: number;\n};\n\n/**\n * In Expo Router, the params are available at all levels of the routing config\n * @param routes\n * @returns\n */\nexport function populateParams(routes?: ParsedRoute[], params?: Record<string, any>) {\n  if (!routes || !params || Object.keys(params).length === 0) return;\n\n  for (const route of routes) {\n    Object.assign(route, { params });\n  }\n\n  return routes;\n}\n\nexport function safelyDecodeURIComponent(str: string) {\n  try {\n    return decodeURIComponent(str);\n  } catch {\n    return str;\n  }\n}\n\ninterface UrlWithReactNavigationConcessions {\n  path: string;\n  nonstandardPathname: string;\n  hash: string;\n  pathWithoutGroups: string;\n}\n\nexport function getUrlWithReactNavigationConcessions(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n): UrlWithReactNavigationConcessions {\n  const pathWithoutGroups = stripGroupSegmentsFromPath(stripBaseUrl(path, baseUrl));\n\n  let pathname = '';\n  let hash = '';\n  try {\n    // NOTE(@kitten): This used to use a dummy base URL for parsing (phony [.] example)\n    // However, this seems to get flagged since it's preserved 1:1 in the output bytecode by certain scanners\n    // Instead, we use an empty `file:` URL. This will still perform `pathname` normalization, search parameter parsing\n    // encoding, and all other logic, except the logic that applies to hostnames and protocols, and also not leave a\n    // dummy URL in the output bytecode\n    const parsed = new URL(path, 'file:');\n    pathname = parsed.pathname;\n    hash = parsed.hash;\n  } catch {\n    // Do nothing with invalid URLs.\n  }\n\n  const withoutBaseUrl = stripBaseUrl(pathname, baseUrl);\n  return {\n    path,\n    // Make sure there is a trailing slash\n    // The slashes are at the end, not the beginning\n    nonstandardPathname: withoutBaseUrl.replace(/^\\/+/g, '').replace(/\\/+$/g, '') + '/',\n    hash,\n    pathWithoutGroups,\n  };\n}\n\nexport function createConfig(\n  screen: string,\n  pattern: string,\n  routeNames: string[],\n  config: Record<string, any> = {}\n): Omit<ExpoRouteConfig, 'isInitial'> {\n  const parts: string[] = [];\n  let isDynamic = false;\n  const isIndex = screen === 'index' || screen.endsWith('/index');\n  let staticPartCount = 0;\n\n  for (const part of pattern.split('/')) {\n    if (part) {\n      // If any part is dynamic, then the route is dynamic\n      const isDynamicPart =\n        part.startsWith(':') || part.startsWith('*') || part.includes('*not-found');\n\n      isDynamic ||= isDynamicPart;\n\n      if (!matchGroupName(part)) {\n        parts.push(part);\n\n        if (!isDynamicPart) {\n          staticPartCount++;\n        }\n      }\n    }\n  }\n\n  const hasChildren = config.screens ? !!Object.keys(config.screens)?.length : false;\n  const type = hasChildren ? 'layout' : isDynamic ? 'dynamic' : 'static';\n\n  if (isIndex) {\n    parts.push('index');\n    staticPartCount++;\n  }\n\n  return {\n    type,\n    isIndex,\n    hasChildren,\n    parts,\n    staticPartCount,\n    userReadableName: [...routeNames.slice(0, -1), config.path || screen].join('/'),\n    // Don't include the __root route name\n    expandedRouteNames: routeNames.slice(1).flatMap((name) => {\n      return name.split('/');\n    }),\n  };\n}\n\nexport function assertScreens(options?: Options<object>): asserts options is Options<object> {\n  if (!options?.screens) {\n    throw Error(\"You must pass a 'screens' object to 'getStateFromPath' to generate a path.\");\n  }\n}\n\nexport function configRegExp(config: RouteConfig) {\n  return config.pattern\n    ? new RegExp(`^(${config.pattern.split('/').map(formatRegexPattern).join('')})$`)\n    : undefined;\n}\n\nexport function isDynamicPart(p: string) {\n  return p.length > 1 && (p.startsWith(':') || p.startsWith('*'));\n}\n\nexport function replacePart(p: string) {\n  return p.replace(/^[:*]/, '').replace(/\\?$/, '');\n}\n\nexport function getParamValue(p: string, value: string) {\n  if (p.startsWith('*')) {\n    const values = value.split('/').filter((v) => v !== '');\n    return values.length === 0 && p.endsWith('?') ? undefined : values;\n  } else {\n    return value;\n  }\n}\n\nfunction formatRegexPattern(it: string): string {\n  // Allow spaces in file path names.\n  it = it.replace(' ', '%20');\n\n  if (it.startsWith(':')) {\n    // TODO: Remove unused match group\n    return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  } else if (it.startsWith('*')) {\n    return `((.*\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  }\n\n  // Strip groups from the matcher\n  if (matchGroupName(it) != null) {\n    // Groups are optional segments\n    // this enables us to match `/bar` and `/(foo)/bar` for the same route\n    // NOTE(EvanBacon): Ignore this match in the regex to avoid capturing the group\n    return `(?:${escape(it)}\\\\/)?`;\n  }\n\n  return escape(it) + `\\\\/`;\n}\n\nexport function handleUrlParams(route: ParsedRoute, params?: queryString.ParsedQuery) {\n  if (params) {\n    route.params = Object.assign(Object.create(null), route.params) as Record<string, any>;\n    for (const [name, value] of Object.entries(params)) {\n      if (route.params?.[name]) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`\n          );\n        }\n      }\n\n      if (!route.params?.[name]) {\n        route.params[name] = value;\n        continue;\n      }\n    }\n\n    if (Object.keys(route.params).length === 0) {\n      delete route.params;\n    }\n  }\n}\n\nexport function spreadParamsAcrossAllStates(state: InitialState, params?: Record<string, any>) {\n  while (state) {\n    const route = state.routes[0];\n    (route as any).params = Object.assign({}, route.params, params);\n  }\n}\n\nexport function stripBaseUrl(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      return path.replace(/^\\/+/g, '/').replace(new RegExp(`^\\\\/?${escape(baseUrl)}`, 'g'), '');\n    }\n  }\n  return path;\n}\n\nexport function matchForEmptyPath(configs: RouteConfig[]) {\n  // We need to add special handling of empty path so navigation to empty path also works\n  // When handling empty path, we should only look at the root level config\n\n  // NOTE(EvanBacon): We only care about matching leaf nodes.\n  const leafNodes = configs\n    .filter((config) => !config.hasChildren)\n    .map((value) => {\n      return {\n        ...value,\n        // Collapse all levels of group segments before testing.\n        // This enables `app/(one)/(two)/index.js` to be matched.\n        path: stripGroupSegmentsFromPath(value.path),\n      };\n    });\n\n  const match =\n    leafNodes.find(\n      (config) =>\n        // NOTE(EvanBacon): Test leaf node index routes that either don't have a regex or match an empty string.\n        config.path === '' && (!config.regex || config.regex.test(''))\n    ) ??\n    leafNodes.find(\n      (config) =>\n        // NOTE(EvanBacon): Test leaf node dynamic routes that match an empty string.\n        config.path.startsWith(':') && config.regex!.test('')\n    ) ??\n    // NOTE(EvanBacon): Test leaf node deep dynamic routes that match a slash.\n    // This should be done last to enable dynamic routes having a higher priority.\n    leafNodes.find((config) => config.path.startsWith('*') && config.regex!.test('/'));\n\n  return match;\n}\n\nexport function appendIsInitial(initialRoutes: InitialRouteConfig[]) {\n  const resolvedInitialPatterns = initialRoutes.map((route) =>\n    joinPaths(...route.parentScreens, route.initialRouteName)\n  );\n\n  return function (config: RouteConfig) {\n    // TODO(EvanBacon): Probably a safer way to do this\n    // Mark initial routes to give them potential priority over other routes that match.\n    config.isInitial = resolvedInitialPatterns.includes(config.routeNames.join('/'));\n    return config;\n  };\n}\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nexport function getRouteConfigSorter(previousSegments: string[] = []) {\n  return function sortConfigs(a: RouteConfig, b: RouteConfig) {\n    // Sort config so that:\n    // - the most exhaustive ones are always at the beginning\n    // - patterns with wildcard are always at the end\n\n    // If 2 patterns are same, move the one with less route names up\n    // This is an error state, so it's only useful for consistent error messages\n    if (a.pattern === b.pattern) {\n      return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));\n    }\n\n    /*\n     * If one of the patterns starts with the other, it is earlier in the config sorting.\n     * However, configs are a mix of route configs and layout configs\n     * e.g There will be a config for `/(group)`, but maybe there isn't a `/(group)/index.tsx`\n     *\n     * This is because you can navigate to a directory and its navigator will determine the route\n     * These routes should be later in the config sorting, as their patterns are very open\n     * and will prevent routes from being matched\n     *\n     * Therefore before we compare segment parts, we force these layout configs later in the sorting\n     *\n     * NOTE(marklawlor): Is this a feature we want? I'm unsure if this is a gimmick or a feature.\n     */\n    if (a.pattern.startsWith(b.pattern) && !b.isIndex) {\n      return -1;\n    }\n\n    if (b.pattern.startsWith(a.pattern) && !a.isIndex) {\n      return 1;\n    }\n\n    /*\n     * Static routes should always be higher than dynamic and layout routes.\n     */\n    if (a.type === 'static' && b.type !== 'static') {\n      return -1;\n    } else if (a.type !== 'static' && b.type === 'static') {\n      return 1;\n    }\n\n    /*\n     * If the routes have any static segments, the one the most static segments should be higher\n     */\n    if (a.staticPartCount !== b.staticPartCount) {\n      return b.staticPartCount - a.staticPartCount;\n    }\n\n    /*\n     * If both are static/dynamic or a layout file, then we check group similarity\n     */\n    const similarToPreviousA = previousSegments.filter((value, index) => {\n      return value === a.expandedRouteNames[index] && value.startsWith('(') && value.endsWith(')');\n    });\n\n    const similarToPreviousB = previousSegments.filter((value, index) => {\n      return value === b.expandedRouteNames[index] && value.startsWith('(') && value.endsWith(')');\n    });\n\n    if (\n      (similarToPreviousA.length > 0 || similarToPreviousB.length > 0) &&\n      similarToPreviousA.length !== similarToPreviousB.length\n    ) {\n      // One matches more than the other, so pick the one that matches more\n      return similarToPreviousB.length - similarToPreviousA.length;\n    }\n\n    /*\n     * If there is not difference in similarity, then each non-group segment is compared against each other\n     */\n    for (let i = 0; i < Math.max(a.parts.length, b.parts.length); i++) {\n      // if b is longer, b get higher priority\n      if (a.parts[i] == null) {\n        return 1;\n      }\n      // if a is longer, a get higher priority\n      if (b.parts[i] == null) {\n        return -1;\n      }\n\n      const aWildCard = a.parts[i].startsWith('*');\n      const bWildCard = b.parts[i].startsWith('*');\n      // if both are wildcard we compare next component\n      if (aWildCard && bWildCard) {\n        const aNotFound = a.parts[i].match(/^[*]not-found$/);\n        const bNotFound = b.parts[i].match(/^[*]not-found$/);\n\n        if (aNotFound && bNotFound) {\n          continue;\n        } else if (aNotFound) {\n          return 1;\n        } else if (bNotFound) {\n          return -1;\n        }\n        continue;\n      }\n      // if only a is wild card, b get higher priority\n      if (aWildCard) {\n        return 1;\n      }\n      // if only b is wild card, a get higher priority\n      if (bWildCard) {\n        return -1;\n      }\n\n      const aSlug = a.parts[i].startsWith(':');\n      const bSlug = b.parts[i].startsWith(':');\n      // if both are wildcard we compare next component\n      if (aSlug && bSlug) {\n        const aNotFound = a.parts[i].match(/^[*]not-found$/);\n        const bNotFound = b.parts[i].match(/^[*]not-found$/);\n\n        if (aNotFound && bNotFound) {\n          continue;\n        } else if (aNotFound) {\n          return 1;\n        } else if (bNotFound) {\n          return -1;\n        }\n\n        continue;\n      }\n      // if only a is wild card, b get higher priority\n      if (aSlug) {\n        return 1;\n      }\n      // if only b is wild card, a get higher priority\n      if (bSlug) {\n        return -1;\n      }\n    }\n\n    /*\n     * Both configs are identical in specificity and segments count/type\n     * Try and sort by initial instead.\n     *\n     * TODO: We don't differentiate between the default initialRoute and group specific default routes\n     *\n     * const unstable_settings = {\n     *   \"group\": {\n     *     initialRouteName: \"article\"\n     *  }\n     * }\n     *\n     * \"article\" will be ranked higher because its an initialRoute for a group - even if not your not currently in\n     * that group. The current work around is to ways provide initialRouteName for all groups\n     */\n    if (a.isInitial && !b.isInitial) {\n      return -1;\n    } else if (!a.isInitial && b.isInitial) {\n      return 1;\n    }\n\n    return b.parts.length - a.parts.length;\n  };\n}\n\nexport function parseQueryParams(\n  path: string,\n  route: ParsedRoute,\n  parseConfig?: Record<string, (value: string) => any>,\n  hash?: string\n) {\n  const searchParams = new URL(path, 'https://phony.example').searchParams;\n  const params: Record<string, string | string[]> = Object.create(null);\n\n  if (hash) {\n    params['#'] = hash.slice(1);\n  }\n\n  for (const name of searchParams.keys()) {\n    if (route.params?.[name]) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(\n          `Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`\n        );\n      }\n    } else {\n      const values = parseConfig?.hasOwnProperty(name)\n        ? searchParams.getAll(name).map((value) => parseConfig[name](value))\n        : searchParams.getAll(name);\n\n      // searchParams.getAll returns an array.\n      // if we only have a single value, and its not an array param, we need to extract the value\n      params[name] = values.length === 1 ? values[0] : values;\n    }\n  }\n\n  return Object.keys(params).length ? params : undefined;\n}\n\nexport function cleanPath(path: string) {\n  path = path\n    // let remaining = path\n    // END FORK\n    .replace(/\\/+/g, '/') // Replace multiple slash (//) with single ones\n    .replace(/^\\//, '') // Remove extra leading slash\n    .replace(/\\?.*$/, ''); // Remove query params which we will handle later\n\n  // Make sure there is a trailing slash\n  return path.endsWith('/') ? path : `${path}/`;\n}\n\nexport function routePatternToRegex(pattern: string) {\n  return new RegExp(\n    `^(${pattern\n      .split('/')\n      .map((it) => {\n        if (it.startsWith('(') && it.endsWith(')')) {\n          return `${it}?`;\n        } else if (it.startsWith(':')) {\n          return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n        }\n\n        return `${it === '*' ? '.*' : escape(it)}\\\\/`;\n      })\n      .join('')})`\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}