{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function () {\n  var ownKeys = function (o) {\n    ownKeys = Object.getOwnPropertyNames || function (o) {\n      var ar = [];\n      for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n      return ar;\n    };\n    return ownKeys(o);\n  };\n  return function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n    __setModuleDefault(result, mod);\n    return result;\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPathFromState = getPathFromState;\nexports.getPathDataFromState = getPathDataFromState;\nexports.appendBaseUrl = appendBaseUrl;\nconst queryString = __importStar(require(\"query-string\"));\nconst expo = __importStar(require(\"./getPathFromState-forks\"));\nconst navigationParams_1 = require(\"../navigationParams\");\nconst getActiveRoute = state => {\n  const route = typeof state.index === 'number' ? state.routes[state.index] : state.routes[state.routes.length - 1];\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n  return route;\n};\nlet cachedNormalizedConfigs = [undefined, {}];\nfunction getPathFromState(state, options) {\n  return getPathDataFromState(state, options).path;\n}\nfunction getPathDataFromState(state, options) {\n  if (state == null) {\n    throw Error(\"Got 'undefined' for the navigation state. You must pass a valid state object.\");\n  }\n  if (options) {\n    expo.validatePathConfig(options);\n  }\n  if (cachedNormalizedConfigs[0] !== options?.screens) {\n    cachedNormalizedConfigs = [options?.screens, options?.screens ? createNormalizedConfigs(options.screens) : {}];\n  }\n  const configs = cachedNormalizedConfigs[1];\n  let path = '/';\n  let current = state;\n  const allParams = {};\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index];\n    let pattern;\n    let focusedParams;\n    const focusedRoute = getActiveRoute(state);\n    let currentOptions = configs;\n    const nestedRouteNames = [];\n    let hasNext = true;\n    while (route.name in currentOptions && hasNext) {\n      pattern = currentOptions[route.name].pattern;\n      nestedRouteNames.push(route.name);\n      if (route.params) {\n        const stringify = currentOptions[route.name]?.stringify;\n        const currentParams = expo.fixCurrentParams(allParams, route, stringify);\n        if (focusedRoute === route) {\n          focusedParams = Object.assign({}, currentParams);\n          pattern?.split('/').filter(p => expo.isDynamicPart(p)).forEach(p => {\n            const name = expo.getParamName(p);\n            if (focusedParams) {\n              delete focusedParams[name];\n            }\n          });\n        }\n      }\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        const screens = currentOptions[route.name].screens;\n        const targetScreen = route.params && 'screen' in route.params && typeof route.params.screen === 'string' ? route.params.screen : 'index';\n        const screen = screens ? screens[targetScreen] ? targetScreen : Object.keys(screens)[0] : undefined;\n        if (screen && screens && currentOptions[route.name].screens?.[screen]) {\n          route = Object.assign({}, screens[screen], {\n            name: screen,\n            key: screen\n          });\n          currentOptions = screens;\n        } else {\n          hasNext = false;\n        }\n      } else {\n        index = typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;\n        const nextRoute = route.state.routes[index];\n        const nestedConfig = currentOptions[route.name].screens;\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute;\n          currentOptions = nestedConfig;\n        } else {\n          hasNext = false;\n        }\n      }\n    }\n    if (pattern === undefined) {\n      pattern = nestedRouteNames.join('/');\n    }\n    if (currentOptions[route.name] !== undefined) {\n      path += expo.getPathWithConventionsCollapsed(Object.assign({}, options, {\n        pattern,\n        route,\n        params: allParams,\n        initialRouteName: configs[route.name]?.initialRouteName\n      }));\n    } else if (!route.name.startsWith('+')) {\n      path += encodeURIComponent(route.name);\n    }\n    if (!focusedParams) {\n      focusedParams = focusedRoute.params;\n    }\n    if (route.state) {\n      path += '/';\n    } else if (focusedParams) {\n      for (const param in focusedParams) {\n        if (focusedParams[param] === 'undefined') {\n          delete focusedParams[param];\n        }\n      }\n      delete focusedParams['#'];\n      focusedParams = (0, navigationParams_1.removeInternalExpoRouterParams)(focusedParams);\n      const query = queryString.stringify(focusedParams, {\n        sort: false\n      });\n      if (query) {\n        path += `?${query}`;\n      }\n    }\n    current = route.state;\n  }\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n  if (options?.path) {\n    path = joinPaths(options.path, path);\n  }\n  path = expo.appendBaseUrl(path);\n  if (allParams['#']) {\n    path += `#${allParams['#']}`;\n  }\n  return {\n    path,\n    params: allParams\n  };\n}\nconst joinPaths = (...paths) => [].concat(...paths.map(p => p.split('/'))).filter(Boolean).join('/');\nconst createConfigItem = (config, parentPattern) => {\n  if (typeof config === 'string') {\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n    return {\n      pattern\n    };\n  }\n  if (config.exact && config.path === undefined) {\n    throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");\n  }\n  const pattern = config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';\n  const screens = config.screens ? createNormalizedConfigs(config.screens, pattern) : undefined;\n  return {\n    pattern: pattern?.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens\n  };\n};\nconst createNormalizedConfigs = (options, pattern) => Object.fromEntries(Object.entries(options).map(([name, c]) => {\n  const result = createConfigItem(c, pattern);\n  return [name, result];\n}));\nfunction appendBaseUrl(path, baseUrl = \"\") {\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      return `/${baseUrl.replace(/^\\/+/, '').replace(/\\/$/, '')}${path}`;\n    }\n  }\n  return path;\n}","map":{"version":3,"names":["exports","getPathFromState","getPathDataFromState","appendBaseUrl","queryString","__importStar","require","expo","navigationParams_1","getActiveRoute","state","route","index","routes","length","cachedNormalizedConfigs","undefined","options","path","Error","validatePathConfig","screens","createNormalizedConfigs","configs","current","allParams","pattern","focusedParams","focusedRoute","currentOptions","nestedRouteNames","hasNext","name","push","params","stringify","currentParams","fixCurrentParams","Object","assign","split","filter","p","isDynamicPart","forEach","getParamName","targetScreen","screen","keys","key","nextRoute","nestedConfig","join","getPathWithConventionsCollapsed","initialRouteName","startsWith","encodeURIComponent","param","removeInternalExpoRouterParams","query","sort","replace","joinPaths","paths","concat","map","Boolean","createConfigItem","config","parentPattern","exact","fromEntries","entries","c","result","baseUrl","process","env","NODE_ENV"],"sources":["/Users/sbudhwar/workspace/github/tomanage/node_modules/expo-router/src/fork/getPathFromState.ts"],"sourcesContent":["import { PathConfig, PathConfigMap } from '@react-navigation/native';\nimport type { NavigationState, PartialState, Route } from '@react-navigation/routers';\nimport * as queryString from 'query-string';\n\nimport * as expo from './getPathFromState-forks';\nimport type { ExpoConfigItem, ExpoOptions } from './getPathFromState-forks';\nimport { removeInternalExpoRouterParams } from '../navigationParams';\n\n// START FORK\nexport type Options<ParamList extends object> = ExpoOptions & {\n  path?: string;\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n// END FORK\n\nexport type State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\nexport type StringifyConfig = Record<string, (value: any) => string>;\n\n// START FORK\ntype ConfigItem = ExpoConfigItem & {\n  pattern?: string;\n  stringify?: StringifyConfig;\n  screens?: Record<string, ConfigItem>;\n};\n// END FORK\n\nconst getActiveRoute = (state: State): { name: string; params?: object } => {\n  const route =\n    typeof state.index === 'number'\n      ? state.routes[state.index]\n      : state.routes[state.routes.length - 1];\n\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n\n  return route;\n};\n\nlet cachedNormalizedConfigs: [PathConfigMap<object> | undefined, Record<string, ConfigItem>] = [\n  undefined,\n  {},\n];\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * @example\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         stringify: { author: author => author.toLowerCase() }\n *       }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport function getPathFromState<ParamList extends object>(\n  state: State,\n  options?: Options<ParamList>\n): string {\n  return getPathDataFromState(state, options).path;\n}\n\nexport function getPathDataFromState<ParamList extends object>(\n  state: State,\n  options?: Options<ParamList>\n) {\n  if (state == null) {\n    throw Error(\"Got 'undefined' for the navigation state. You must pass a valid state object.\");\n  }\n\n  if (options) {\n    // START FORK\n    expo.validatePathConfig(options);\n    // validatePathConfig(options);\n    // END FORK\n  }\n\n  // Create a normalized configs object which will be easier to use\n  if (cachedNormalizedConfigs[0] !== options?.screens) {\n    cachedNormalizedConfigs = [\n      options?.screens,\n      options?.screens ? createNormalizedConfigs(options.screens) : {},\n    ];\n  }\n  const configs: Record<string, ConfigItem> = cachedNormalizedConfigs[1];\n\n  let path = '/';\n  let current: State | undefined = state;\n\n  const allParams: Record<string, any> = {};\n\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index] as Route<string> & {\n      state?: State;\n    };\n\n    let pattern: string | undefined;\n\n    let focusedParams: Record<string, any> | undefined;\n    const focusedRoute = getActiveRoute(state);\n    let currentOptions = configs;\n\n    // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\n    const nestedRouteNames: string[] = [];\n\n    let hasNext = true;\n\n    while (route.name in currentOptions && hasNext) {\n      pattern = currentOptions[route.name].pattern;\n\n      nestedRouteNames.push(route.name);\n\n      if (route.params) {\n        const stringify = currentOptions[route.name]?.stringify;\n\n        // START FORK\n        // This mutates allParams\n        const currentParams = expo.fixCurrentParams(allParams, route, stringify);\n\n        // const currentParams = Object.fromEntries(\n        //   Object.entries(route.params).map(([key, value]) => [\n        //     key,\n        //     stringify?.[key] ? stringify[key](value) : String(value),\n        //   ])\n        // );\n\n        // if (pattern) {\n        //   Object.assign(allParams, currentParams);\n        // }\n        // END FORK\n\n        if (focusedRoute === route) {\n          // If this is the focused route, keep the params for later use\n          // We save it here since it's been stringified already\n          focusedParams = { ...currentParams };\n\n          pattern\n            ?.split('/')\n            .filter((p) => expo.isDynamicPart(p))\n            // eslint-disable-next-line no-loop-func\n            .forEach((p) => {\n              const name = expo.getParamName(p);\n\n              // Remove the params present in the pattern since we'll only use the rest for query string\n              if (focusedParams) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete focusedParams[name];\n              }\n            });\n        }\n      }\n\n      // If there is no `screens` property or no nested state, we return pattern\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        // START FORK\n        // Expo Router allows you to navigate to a (group) and not specify a target screen\n        // This is different from React Navigation, which requires a target screen\n        // We need to handle this case here, by selecting either the index screen or the first screen of the group\n\n        // IMPORTANT: This does not affect groups that use _layout files with initialRouteNames\n        // Layout files create a new route config. This only affects groups without layouts that have their screens\n        // hoisted.\n\n        // Example:\n        // - /home/_layout\n        // - /home/(a|b|c)/index          --> Hoisted to /home/_layout navigator\n        // - /home/(a|b|c)/other          --> Hoisted to /home/_layout navigator\n        // - /home/(profile)/me           --> Hoisted to /home/_layout navigator\n        //\n        // route.push('/home/(a)')        --> This should navigate to /home/(a)/index\n        // route.push('/home/(profile)')  --> This should navigate to /home/(profile)/me\n        const screens = currentOptions[route.name].screens;\n\n        // Determine what screen the user wants to navigate to. If no screen is specified, assume there is an index screen\n        // In the examples above, this ensures that /home/(a) navigates to /home/(a)/index\n        const targetScreen =\n          // This is typed as unknown, so we need to add these extra assertions\n          route.params && 'screen' in route.params && typeof route.params.screen === 'string'\n            ? route.params.screen\n            : 'index';\n\n        // If the target screen is not in the screens object, default to the first screen\n        // In the examples above, this ensures that /home/(profile) navigates to /home/(profile)/me\n        // As there is no index screen in the group\n        const screen = screens\n          ? screens[targetScreen]\n            ? targetScreen\n            : Object.keys(screens)[0]\n          : undefined;\n\n        if (screen && screens && currentOptions[route.name].screens?.[screen]) {\n          route = { ...screens[screen], name: screen, key: screen };\n          currentOptions = screens;\n        } else {\n          hasNext = false;\n        }\n        // hasNext = false;\n        // END FORK\n      } else {\n        index =\n          typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;\n\n        const nextRoute = route.state.routes[index];\n        const nestedConfig = currentOptions[route.name].screens;\n\n        // if there is config for next route name, we go deeper\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute as Route<string> & { state?: State };\n          currentOptions = nestedConfig;\n        } else {\n          // If not, there is no sense in going deeper in config\n          hasNext = false;\n        }\n      }\n    }\n\n    if (pattern === undefined) {\n      pattern = nestedRouteNames.join('/');\n    }\n\n    if (currentOptions[route.name] !== undefined) {\n      // START FORK\n      path += expo.getPathWithConventionsCollapsed({\n        ...options,\n        pattern,\n        route,\n        params: allParams,\n        initialRouteName: configs[route.name]?.initialRouteName,\n      });\n      // path += pattern\n      //   .split('/')\n      //   .map((p) => {\n      //     const name = getParamName(p);\n\n      //     // We don't know what to show for wildcard patterns\n      //     // Showing the route name seems ok, though whatever we show here will be incorrect\n      //     // Since the page doesn't actually exist\n      //     if (p === '*') {\n      //       return route.name;\n      //     }\n\n      //     // If the path has a pattern for a param, put the param in the path\n      //     if (p.startsWith(':')) {\n      //       const value = allParams[name];\n\n      //       if (value === undefined && p.endsWith('?')) {\n      //         // Optional params without value assigned in route.params should be ignored\n      //         return '';\n      //       }\n\n      //       // Valid characters according to\n      //       // https://datatracker.ietf.org/doc/html/rfc3986#section-3.3 (see pchar definition)\n      //       return String(value).replace(/[^A-Za-z0-9\\-._~!$&'()*+,;=:@]/g, (char) =>\n      //         encodeURIComponent(char)\n      //       );\n      //     }\n\n      //     return encodeURIComponent(p);\n      //   })\n      //   .join('/');\n      // } else {\n    } else if (!route.name.startsWith('+')) {\n      path += encodeURIComponent(route.name);\n    }\n    // END FORK\n\n    if (!focusedParams) {\n      focusedParams = focusedRoute.params;\n    }\n\n    if (route.state) {\n      path += '/';\n    } else if (focusedParams) {\n      for (const param in focusedParams) {\n        if (focusedParams[param] === 'undefined') {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete focusedParams[param];\n        }\n      }\n\n      // START FORK\n      delete focusedParams['#'];\n      focusedParams = removeInternalExpoRouterParams(focusedParams);\n      // END FORK\n\n      const query = queryString.stringify(focusedParams, { sort: false });\n      if (query) {\n        path += `?${query}`;\n      }\n    }\n\n    current = route.state;\n  }\n\n  // Remove multiple as well as trailing slashes\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n\n  // Include the root path if specified\n  if (options?.path) {\n    path = joinPaths(options.path, path);\n  }\n\n  // START FORK\n  path = expo.appendBaseUrl(path);\n  if (allParams['#']) {\n    path += `#${allParams['#']}`;\n  }\n  // END FORK\n\n  // START FORK\n  return { path, params: allParams };\n  // END FORK\n}\n\n// const getParamName = (pattern: string) => pattern.replace(/^:/, '').replace(/\\?$/, '');\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nconst createConfigItem = (\n  config: PathConfig<object> | string,\n  parentPattern?: string\n): ConfigItem => {\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    return { pattern };\n  }\n\n  if (config.exact && config.path === undefined) {\n    throw new Error(\n      \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n    );\n  }\n\n  // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n  const pattern =\n    config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';\n\n  const screens = config.screens ? createNormalizedConfigs(config.screens, pattern) : undefined;\n\n  return {\n    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n    pattern: pattern?.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens,\n  };\n};\n\nconst createNormalizedConfigs = (\n  options: PathConfigMap<object>,\n  pattern?: string\n): Record<string, ConfigItem> =>\n  Object.fromEntries(\n    Object.entries(options).map(([name, c]) => {\n      const result = createConfigItem(c, pattern);\n\n      return [name, result];\n    })\n  );\n\nexport function appendBaseUrl(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      return `/${baseUrl.replace(/^\\/+/, '').replace(/\\/$/, '')}${path}`;\n    }\n  }\n  return path;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}