{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTabPathFromRootStateByHref = getTabPathFromRootStateByHref;\nexports.getPreloadedRouteFromRootStateByHref = getPreloadedRouteFromRootStateByHref;\nexports.deepEqual = deepEqual;\nconst router_store_1 = require(\"../../global-state/router-store\");\nconst routing_1 = require(\"../../global-state/routing\");\nconst href_1 = require(\"../href\");\nconst navigationParams_1 = require(\"../../navigationParams\");\nfunction getTabPathFromRootStateByHref(href, rootState) {\n  const hrefState = router_store_1.store.getStateForHref((0, href_1.resolveHref)(href));\n  const state = rootState;\n  if (!hrefState || !state) {\n    return [];\n  }\n  const {\n    navigationRoutes\n  } = (0, routing_1.findDivergentState)(hrefState, state, true);\n  if (!navigationRoutes.length) {\n    return [];\n  }\n  const tabPath = [];\n  navigationRoutes.forEach((route, i, arr) => {\n    if (route.state?.type === 'tab') {\n      const tabState = route.state;\n      const oldTabKey = tabState.routes[tabState.index].key;\n      if (!arr[i + 1]) {\n        throw new Error(`New tab route is missing for ${route.key}. This is likely an internal Expo Router bug.`);\n      }\n      const newTabKey = arr[i + 1].key;\n      tabPath.push({\n        oldTabKey,\n        newTabKey\n      });\n    }\n  });\n  return tabPath;\n}\nfunction getPreloadedRouteFromRootStateByHref(href, rootState) {\n  const hrefState = router_store_1.store.getStateForHref((0, href_1.resolveHref)(href));\n  const state = rootState;\n  if (!hrefState || !state) {\n    return undefined;\n  }\n  const {\n    navigationState,\n    actionStateRoute\n  } = (0, routing_1.findDivergentState)(hrefState, state, true);\n  if (!navigationState || !actionStateRoute) {\n    return undefined;\n  }\n  if (navigationState.type === 'stack') {\n    const stackState = navigationState;\n    const payload = (0, routing_1.getPayloadFromStateRoute)(actionStateRoute);\n    const preloadedRoute = stackState.preloadedRoutes.find(route => route.name === actionStateRoute.name && deepEqual((0, navigationParams_1.removeInternalExpoRouterParams)(route.params), (0, navigationParams_1.removeInternalExpoRouterParams)(payload.params)));\n    const activeRoute = stackState.routes[stackState.index];\n    if (activeRoute.name === preloadedRoute?.name && deepEqual((0, navigationParams_1.removeInternalExpoRouterParams)(activeRoute.params ?? {}), (0, navigationParams_1.removeInternalExpoRouterParams)(payload.params ?? {}))) {\n      return undefined;\n    }\n    return preloadedRoute;\n  }\n  return undefined;\n}\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (a == null || b == null) {\n    return false;\n  }\n  if (typeof a !== 'object' || typeof b !== 'object') {\n    return false;\n  }\n  const keys = Object.keys(a);\n  return keys.length === Object.keys(b).length && keys.every(key => deepEqual(a[key], b[key]));\n}","map":{"version":3,"names":["exports","getTabPathFromRootStateByHref","getPreloadedRouteFromRootStateByHref","deepEqual","router_store_1","require","routing_1","href_1","navigationParams_1","href","rootState","hrefState","store","getStateForHref","resolveHref","state","navigationRoutes","findDivergentState","length","tabPath","forEach","route","i","arr","type","tabState","oldTabKey","routes","index","key","Error","newTabKey","push","undefined","navigationState","actionStateRoute","stackState","payload","getPayloadFromStateRoute","preloadedRoute","preloadedRoutes","find","name","removeInternalExpoRouterParams","params","activeRoute","a","b","keys","Object","every"],"sources":["/Users/sbudhwar/workspace/github/tomanage/node_modules/expo-router/src/link/preview/utils.ts"],"sourcesContent":["import {\n  ParamListBase,\n  StackNavigationState,\n  type NavigationRoute,\n  type NavigationState,\n  type TabNavigationState,\n} from '@react-navigation/native';\n\nimport { store, type ReactNavigationState } from '../../global-state/router-store';\nimport { findDivergentState, getPayloadFromStateRoute } from '../../global-state/routing';\nimport { Href } from '../../types';\nimport { resolveHref } from '../href';\nimport { TabPath } from './native';\nimport { removeInternalExpoRouterParams } from '../../navigationParams';\n\nexport function getTabPathFromRootStateByHref(\n  href: Href,\n  rootState: ReactNavigationState\n): TabPath[] {\n  const hrefState = store.getStateForHref(resolveHref(href));\n  const state: ReactNavigationState | undefined = rootState;\n  if (!hrefState || !state) {\n    return [];\n  }\n  // Replicating the logic from `linkTo`\n  const { navigationRoutes } = findDivergentState(hrefState, state as NavigationState, true);\n\n  if (!navigationRoutes.length) {\n    return [];\n  }\n\n  const tabPath: TabPath[] = [];\n  navigationRoutes.forEach((route, i, arr) => {\n    if (route.state?.type === 'tab') {\n      const tabState = route.state as TabNavigationState<ParamListBase>;\n      const oldTabKey = tabState.routes[tabState.index].key;\n      // The next route will be either stack inside a tab or a new tab key\n      if (!arr[i + 1]) {\n        throw new Error(\n          `New tab route is missing for ${route.key}. This is likely an internal Expo Router bug.`\n        );\n      }\n      const newTabKey = arr[i + 1].key;\n      tabPath.push({ oldTabKey, newTabKey });\n    }\n  });\n  return tabPath;\n}\n\nexport function getPreloadedRouteFromRootStateByHref(\n  href: Href,\n  rootState: ReactNavigationState\n): NavigationRoute<ParamListBase, string> | undefined {\n  const hrefState = store.getStateForHref(resolveHref(href));\n  const state: ReactNavigationState | undefined = rootState;\n  if (!hrefState || !state) {\n    return undefined;\n  }\n  // Replicating the logic from `linkTo`\n  const { navigationState, actionStateRoute } = findDivergentState(\n    hrefState,\n    state as NavigationState,\n    true\n  );\n\n  if (!navigationState || !actionStateRoute) {\n    return undefined;\n  }\n\n  if (navigationState.type === 'stack') {\n    const stackState = navigationState as StackNavigationState<ParamListBase>;\n    const payload = getPayloadFromStateRoute(actionStateRoute);\n\n    const preloadedRoute = stackState.preloadedRoutes.find(\n      (route) =>\n        route.name === actionStateRoute.name &&\n        deepEqual(\n          removeInternalExpoRouterParams(route.params),\n          removeInternalExpoRouterParams(payload.params)\n        )\n    );\n\n    const activeRoute = stackState.routes[stackState.index];\n    // When the active route is the same as the preloaded route,\n    // then we should not navigate. It aligns with base link behavior.\n    if (\n      activeRoute.name === preloadedRoute?.name &&\n      deepEqual(\n        // using ?? {}, because from our perspective undefined === {}, as both mean no params\n        removeInternalExpoRouterParams(activeRoute.params ?? {}),\n        removeInternalExpoRouterParams(payload.params ?? {})\n      )\n    ) {\n      return undefined;\n    }\n\n    return preloadedRoute;\n  }\n\n  return undefined;\n}\n\nexport function deepEqual(\n  a: { [key: string]: any } | undefined,\n  b: { [key: string]: any } | undefined\n): boolean {\n  if (a === b) {\n    return true;\n  }\n  if (a == null || b == null) {\n    return false;\n  }\n  if (typeof a !== 'object' || typeof b !== 'object') {\n    return false;\n  }\n  const keys = Object.keys(a);\n  return keys.length === Object.keys(b).length && keys.every((key) => deepEqual(a[key], b[key]));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}