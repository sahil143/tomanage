{"ast":null,"code":"import parseErrorStack from '../parseErrorStack';\nclass SyntheticError extends Error {\n  name = '';\n}\nlet exceptionID = 0;\nfunction parseException(e, isFatal) {\n  const stack = parseErrorStack(e?.stack);\n  const currentExceptionID = ++exceptionID;\n  const originalMessage = e.message || '';\n  let message = originalMessage;\n  if (e.componentStack != null) {\n    message += `\\n\\nThis error is located at:${e.componentStack}`;\n  }\n  const namePrefix = e.name == null || e.name === '' ? '' : `${e.name}: `;\n  if (!message.startsWith(namePrefix)) {\n    message = namePrefix + message;\n  }\n  message = e.jsEngine == null ? message : `${message}, js engine: ${e.jsEngine}`;\n  const data = {\n    message,\n    originalMessage: message === originalMessage ? null : originalMessage,\n    name: e.name == null || e.name === '' ? null : e.name,\n    componentStack: typeof e.componentStack === 'string' ? e.componentStack : null,\n    stack,\n    id: currentExceptionID,\n    isFatal,\n    extraData: {\n      jsEngine: e.jsEngine,\n      rawStack: e.stack\n    }\n  };\n  return Object.assign({}, data, {\n    isComponentError: !!e.isComponentError\n  });\n}\nfunction handleException(e) {\n  let error;\n  if (e instanceof Error) {\n    error = e;\n  } else {\n    error = new SyntheticError(e);\n  }\n  require('../../LogBox').default.addException(parseException(error, true));\n}\nconst ErrorUtils = {\n  parseException,\n  handleException,\n  SyntheticError\n};\nexport default ErrorUtils;","map":{"version":3,"names":["parseErrorStack","SyntheticError","Error","name","exceptionID","parseException","e","isFatal","stack","currentExceptionID","originalMessage","message","componentStack","namePrefix","startsWith","jsEngine","data","id","extraData","rawStack","Object","assign","isComponentError","handleException","error","require","default","addException","ErrorUtils"],"sources":["/Users/sbudhwar/workspace/github/tomanage/node_modules/@expo/metro-runtime/src/error-overlay/modules/ExceptionsManager/index.ts"],"sourcesContent":["/**\n * Copyright (c) 650 Industries.\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport parseErrorStack from '../parseErrorStack';\n\ntype ExtendedError = any;\n\nclass SyntheticError extends Error {\n  name: string = '';\n}\n\n/**\n * Handles the developer-visible aspect of errors and exceptions\n */\nlet exceptionID = 0;\n\nfunction parseException(e: ExtendedError, isFatal: boolean) {\n  const stack = parseErrorStack(e?.stack);\n  const currentExceptionID = ++exceptionID;\n  const originalMessage = e.message || '';\n  let message = originalMessage;\n  if (e.componentStack != null) {\n    message += `\\n\\nThis error is located at:${e.componentStack}`;\n  }\n  const namePrefix = e.name == null || e.name === '' ? '' : `${e.name}: `;\n\n  if (!message.startsWith(namePrefix)) {\n    message = namePrefix + message;\n  }\n\n  message = e.jsEngine == null ? message : `${message}, js engine: ${e.jsEngine}`;\n\n  const data = {\n    message,\n    originalMessage: message === originalMessage ? null : originalMessage,\n    name: e.name == null || e.name === '' ? null : e.name,\n    componentStack: typeof e.componentStack === 'string' ? e.componentStack : null,\n    stack,\n    id: currentExceptionID,\n    isFatal,\n    extraData: {\n      jsEngine: e.jsEngine,\n      rawStack: e.stack,\n    },\n  };\n\n  return {\n    ...data,\n    isComponentError: !!e.isComponentError,\n  };\n}\n\n/**\n * Logs exceptions to the (native) console and displays them\n */\nfunction handleException(e: any) {\n  let error: Error;\n  if (e instanceof Error) {\n    error = e;\n  } else {\n    // Workaround for reporting errors caused by `throw 'some string'`\n    // Unfortunately there is no way to figure out the stacktrace in this\n    // case, so if you ended up here trying to trace an error, look for\n    // `throw '<error message>'` somewhere in your codebase.\n    error = new SyntheticError(e);\n  }\n\n  require('../../LogBox').default.addException(parseException(error, true));\n}\n\nconst ErrorUtils = {\n  parseException,\n  handleException,\n  SyntheticError,\n};\n\nexport default ErrorUtils;\n"],"mappings":"AAQA,OAAOA,eAAe,MAAM,oBAAoB;AAIhD,MAAMC,cAAc,SAASC,KAAK,CAAC;EACjCC,IAAI,GAAW,EAAE;AACnB;AAKA,IAAIC,WAAW,GAAG,CAAC;AAEnB,SAASC,cAAcA,CAACC,CAAgB,EAAEC,OAAgB,EAAE;EAC1D,MAAMC,KAAK,GAAGR,eAAe,CAACM,CAAC,EAAEE,KAAK,CAAC;EACvC,MAAMC,kBAAkB,GAAG,EAAEL,WAAW;EACxC,MAAMM,eAAe,GAAGJ,CAAC,CAACK,OAAO,IAAI,EAAE;EACvC,IAAIA,OAAO,GAAGD,eAAe;EAC7B,IAAIJ,CAAC,CAACM,cAAc,IAAI,IAAI,EAAE;IAC5BD,OAAO,IAAI,gCAAgCL,CAAC,CAACM,cAAc,EAAE;EAC/D;EACA,MAAMC,UAAU,GAAGP,CAAC,CAACH,IAAI,IAAI,IAAI,IAAIG,CAAC,CAACH,IAAI,KAAK,EAAE,GAAG,EAAE,GAAG,GAAGG,CAAC,CAACH,IAAI,IAAI;EAEvE,IAAI,CAACQ,OAAO,CAACG,UAAU,CAACD,UAAU,CAAC,EAAE;IACnCF,OAAO,GAAGE,UAAU,GAAGF,OAAO;EAChC;EAEAA,OAAO,GAAGL,CAAC,CAACS,QAAQ,IAAI,IAAI,GAAGJ,OAAO,GAAG,GAAGA,OAAO,gBAAgBL,CAAC,CAACS,QAAQ,EAAE;EAE/E,MAAMC,IAAI,GAAG;IACXL,OAAO;IACPD,eAAe,EAAEC,OAAO,KAAKD,eAAe,GAAG,IAAI,GAAGA,eAAe;IACrEP,IAAI,EAAEG,CAAC,CAACH,IAAI,IAAI,IAAI,IAAIG,CAAC,CAACH,IAAI,KAAK,EAAE,GAAG,IAAI,GAAGG,CAAC,CAACH,IAAI;IACrDS,cAAc,EAAE,OAAON,CAAC,CAACM,cAAc,KAAK,QAAQ,GAAGN,CAAC,CAACM,cAAc,GAAG,IAAI;IAC9EJ,KAAK;IACLS,EAAE,EAAER,kBAAkB;IACtBF,OAAO;IACPW,SAAS,EAAE;MACTH,QAAQ,EAAET,CAAC,CAACS,QAAQ;MACpBI,QAAQ,EAAEb,CAAC,CAACE;IACd;EACF,CAAC;EAED,OAAAY,MAAA,CAAAC,MAAA,KACKL,IAAI;IACPM,gBAAgB,EAAE,CAAC,CAAChB,CAAC,CAACgB;EAAgB;AAE1C;AAKA,SAASC,eAAeA,CAACjB,CAAM,EAAE;EAC/B,IAAIkB,KAAY;EAChB,IAAIlB,CAAC,YAAYJ,KAAK,EAAE;IACtBsB,KAAK,GAAGlB,CAAC;EACX,CAAC,MAAM;IAKLkB,KAAK,GAAG,IAAIvB,cAAc,CAACK,CAAC,CAAC;EAC/B;EAEAmB,OAAO,CAAC,cAAc,CAAC,CAACC,OAAO,CAACC,YAAY,CAACtB,cAAc,CAACmB,KAAK,EAAE,IAAI,CAAC,CAAC;AAC3E;AAEA,MAAMI,UAAU,GAAG;EACjBvB,cAAc;EACdkB,eAAe;EACftB;AACF,CAAC;AAED,eAAe2B,UAAU","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}