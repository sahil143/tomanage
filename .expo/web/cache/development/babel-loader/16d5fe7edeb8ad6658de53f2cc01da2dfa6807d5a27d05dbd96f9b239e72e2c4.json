{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultRouteInfo = void 0;\nexports.getRouteInfoFromState = getRouteInfoFromState;\nconst constants_1 = require(\"../constants\");\nconst getPathFromState_forks_1 = require(\"../fork/getPathFromState-forks\");\nexports.defaultRouteInfo = {\n  unstable_globalHref: '',\n  searchParams: new URLSearchParams(),\n  pathname: '/',\n  params: {},\n  segments: [],\n  pathnameWithParams: '/',\n  isIndex: false\n};\nfunction getRouteInfoFromState(state) {\n  if (!state) return exports.defaultRouteInfo;\n  const index = 'index' in state ? state.index ?? 0 : 0;\n  let route = state.routes[index];\n  if (route.name === constants_1.NOT_FOUND_ROUTE_NAME || route.name === constants_1.SITEMAP_ROUTE_NAME) {\n    const path = route.path || (route.name === constants_1.NOT_FOUND_ROUTE_NAME ? '/' : `/${route.name}`);\n    return Object.assign({}, exports.defaultRouteInfo, {\n      unstable_globalHref: (0, getPathFromState_forks_1.appendBaseUrl)(path),\n      pathname: path,\n      pathnameWithParams: path,\n      segments: [route.name]\n    });\n  }\n  if (route.name !== constants_1.INTERNAL_SLOT_NAME) {\n    throw new Error(`Expected the first route to be ${constants_1.INTERNAL_SLOT_NAME}, but got ${route.name}`);\n  }\n  state = route.state;\n  const segments = [];\n  let params = Object.create(null);\n  while (state) {\n    route = state.routes['index' in state && state.index ? state.index : 0];\n    Object.assign(params, route.params);\n    let routeName = route.name;\n    if (routeName.startsWith('/')) {\n      routeName = routeName.slice(1);\n    }\n    segments.push(...routeName.split('/'));\n    state = route.state;\n  }\n  params = Object.fromEntries(Object.entries(params).map(([key, value]) => {\n    if (typeof value === 'string') {\n      return [key, safeDecodeURIComponent(value)];\n    } else if (Array.isArray(value)) {\n      return [key, value.map(v => safeDecodeURIComponent(v))];\n    } else {\n      return [key, value];\n    }\n  }));\n  let routeParams = route.params;\n  while (routeParams && 'screen' in routeParams) {\n    if (typeof routeParams.screen === 'string') {\n      const screen = routeParams.screen.startsWith('/') ? routeParams.screen.slice(1) : routeParams.screen;\n      segments.push(...screen.split('/'));\n    }\n    if (typeof routeParams.params === 'object' && !Array.isArray(routeParams.params)) {\n      routeParams = routeParams.params;\n    } else {\n      routeParams = undefined;\n    }\n  }\n  if (route.params && 'screen' in route.params && route.params.screen === 'string') {\n    const screen = route.params.screen.startsWith('/') ? route.params.screen.slice(1) : route.params.screen;\n    segments.push(...screen.split('/'));\n  }\n  if (segments[segments.length - 1] === 'index') {\n    segments.pop();\n  }\n  delete params['screen'];\n  delete params['params'];\n  const pathParams = new Set();\n  const pathname = '/' + segments.filter(segment => {\n    return !(segment.startsWith('(') && segment.endsWith(')'));\n  }).flatMap(segment => {\n    if (segment === '+not-found') {\n      const notFoundPath = params['not-found'];\n      pathParams.add('not-found');\n      if (typeof notFoundPath === 'undefined') {\n        return [];\n      } else if (Array.isArray(notFoundPath)) {\n        return notFoundPath;\n      } else {\n        return [notFoundPath];\n      }\n    } else if (segment.startsWith('[...') && segment.endsWith(']')) {\n      let paramName = segment.slice(4, -1);\n      if (paramName.endsWith('?')) {\n        paramName = paramName.slice(0, -1);\n      }\n      const values = params[paramName];\n      pathParams.add(paramName);\n      return values || [];\n    } else if (segment.startsWith('[') && segment.endsWith(']')) {\n      const paramName = segment.slice(1, -1);\n      const value = params[paramName];\n      pathParams.add(paramName);\n      return value ? [value] : [];\n    } else {\n      return [segment];\n    }\n  }).join('/');\n  const searchParams = new URLSearchParams(Object.entries(params).flatMap(([key, value]) => {\n    if (pathParams.has(key)) {\n      return [];\n    } else if (Array.isArray(value)) {\n      return value.map(v => [key, v]);\n    }\n    return [[key, value]];\n  }));\n  let hash;\n  if (searchParams.has('#')) {\n    hash = searchParams.get('#') || undefined;\n    searchParams.delete('#');\n  }\n  const searchParamString = searchParams.toString();\n  let pathnameWithParams = searchParamString ? pathname + '?' + searchParamString : pathname;\n  pathnameWithParams = hash ? pathnameWithParams + '#' + hash : pathnameWithParams;\n  return {\n    segments,\n    pathname,\n    params,\n    unstable_globalHref: (0, getPathFromState_forks_1.appendBaseUrl)(pathnameWithParams),\n    searchParams,\n    pathnameWithParams,\n    isIndex: false\n  };\n}\nfunction safeDecodeURIComponent(value) {\n  try {\n    return typeof value === 'string' ? decodeURIComponent(value) : value;\n  } catch {\n    return value;\n  }\n}","map":{"version":3,"names":["exports","getRouteInfoFromState","constants_1","require","getPathFromState_forks_1","defaultRouteInfo","unstable_globalHref","searchParams","URLSearchParams","pathname","params","segments","pathnameWithParams","isIndex","state","index","route","routes","name","NOT_FOUND_ROUTE_NAME","SITEMAP_ROUTE_NAME","path","Object","assign","appendBaseUrl","INTERNAL_SLOT_NAME","Error","create","routeName","startsWith","slice","push","split","fromEntries","entries","map","key","value","safeDecodeURIComponent","Array","isArray","v","routeParams","screen","undefined","length","pop","pathParams","Set","filter","segment","endsWith","flatMap","notFoundPath","add","paramName","values","join","has","hash","get","delete","searchParamString","toString","decodeURIComponent"],"sources":["/Users/sbudhwar/workspace/github/tomanage/node_modules/expo-router/src/global-state/routeInfo.ts"],"sourcesContent":["import type { NavigationState, PartialState } from '@react-navigation/native';\n\nimport type { FocusedRouteState } from './router-store';\nimport { INTERNAL_SLOT_NAME, NOT_FOUND_ROUTE_NAME, SITEMAP_ROUTE_NAME } from '../constants';\nimport { appendBaseUrl } from '../fork/getPathFromState-forks';\n\nexport type UrlObject = {\n  unstable_globalHref: string;\n  pathname: string;\n  readonly params: Record<string, string | string[]>;\n  searchParams: URLSearchParams;\n  segments: string[];\n  pathnameWithParams: string;\n  isIndex: boolean;\n};\n\nexport const defaultRouteInfo: UrlObject = {\n  unstable_globalHref: '',\n  searchParams: new URLSearchParams(),\n  pathname: '/',\n  params: {},\n  segments: [],\n  pathnameWithParams: '/',\n  // TODO: Remove this, it is not used anywhere\n  isIndex: false,\n};\n\n/**\n * A better typed version of `FocusedRouteState` that is easier to parse\n */\ntype StrictState = (FocusedRouteState | NavigationState | PartialState<NavigationState>) & {\n  routes: {\n    key?: string;\n    name: string;\n    params?: StrictFocusedRouteParams;\n    path?: string;\n    state?: StrictState;\n  }[];\n};\n\ntype StrictFocusedRouteParams =\n  | Record<string, string | string[]>\n  | {\n      screen?: string;\n      params?: StrictFocusedRouteParams;\n    };\n\nexport function getRouteInfoFromState(state?: StrictState): UrlObject {\n  if (!state) return defaultRouteInfo;\n\n  const index = 'index' in state ? (state.index ?? 0) : 0;\n  let route = state.routes[index];\n\n  if (route.name === NOT_FOUND_ROUTE_NAME || route.name === SITEMAP_ROUTE_NAME) {\n    const path = route.path || (route.name === NOT_FOUND_ROUTE_NAME ? '/' : `/${route.name}`);\n    return {\n      ...defaultRouteInfo,\n      unstable_globalHref: appendBaseUrl(path),\n      pathname: path,\n      pathnameWithParams: path,\n      segments: [route.name],\n    };\n  }\n\n  if (route.name !== INTERNAL_SLOT_NAME) {\n    throw new Error(`Expected the first route to be ${INTERNAL_SLOT_NAME}, but got ${route.name}`);\n  }\n\n  state = route.state;\n\n  const segments: string[] = [];\n  let params: UrlObject['params'] = Object.create(null);\n\n  while (state) {\n    route = state.routes['index' in state && state.index ? state.index : 0];\n\n    Object.assign(params, route.params);\n\n    let routeName = route.name;\n    if (routeName.startsWith('/')) {\n      routeName = routeName.slice(1);\n    }\n\n    segments.push(...routeName.split('/'));\n    state = route.state;\n  }\n\n  params = Object.fromEntries(\n    Object.entries(params).map(([key, value]) => {\n      if (typeof value === 'string') {\n        return [key, safeDecodeURIComponent(value)];\n      } else if (Array.isArray(value)) {\n        return [key, value.map((v) => safeDecodeURIComponent(v))];\n      } else {\n        return [key, value];\n      }\n    })\n  );\n\n  /**\n   * If React Navigation didn't render the entire tree (e.g it was interrupted in a layout)\n   * then the state maybe incomplete. The reset of the path is in the params, instead of being a route\n   */\n  let routeParams: StrictFocusedRouteParams | undefined = route.params;\n  while (routeParams && 'screen' in routeParams) {\n    if (typeof routeParams.screen === 'string') {\n      const screen = routeParams.screen.startsWith('/')\n        ? routeParams.screen.slice(1)\n        : routeParams.screen;\n      segments.push(...screen.split('/'));\n    }\n\n    if (typeof routeParams.params === 'object' && !Array.isArray(routeParams.params)) {\n      routeParams = routeParams.params;\n    } else {\n      routeParams = undefined;\n    }\n  }\n\n  if (route.params && 'screen' in route.params && route.params.screen === 'string') {\n    const screen = route.params.screen.startsWith('/')\n      ? route.params.screen.slice(1)\n      : route.params.screen;\n    segments.push(...screen.split('/'));\n  }\n\n  if (segments[segments.length - 1] === 'index') {\n    segments.pop();\n  }\n\n  delete params['screen'];\n  delete params['params'];\n\n  const pathParams = new Set<string>();\n\n  const pathname =\n    '/' +\n    segments\n      .filter((segment) => {\n        return !(segment.startsWith('(') && segment.endsWith(')'));\n      })\n      .flatMap((segment) => {\n        if (segment === '+not-found') {\n          const notFoundPath = params['not-found'];\n\n          pathParams.add('not-found');\n\n          if (typeof notFoundPath === 'undefined') {\n            // Not founds are optional, do nothing if its not present\n            return [];\n          } else if (Array.isArray(notFoundPath)) {\n            return notFoundPath;\n          } else {\n            return [notFoundPath];\n          }\n        } else if (segment.startsWith('[...') && segment.endsWith(']')) {\n          let paramName = segment.slice(4, -1);\n\n          // Legacy for React Navigation optional params\n          if (paramName.endsWith('?')) {\n            paramName = paramName.slice(0, -1);\n          }\n\n          const values = params[paramName];\n          pathParams.add(paramName);\n\n          // Catchall params are optional\n          return values || [];\n        } else if (segment.startsWith('[') && segment.endsWith(']')) {\n          const paramName = segment.slice(1, -1);\n          const value = params[paramName];\n          pathParams.add(paramName);\n\n          // Optional params are optional\n          return value ? [value] : [];\n        } else {\n          return [segment];\n        }\n      })\n      .join('/');\n\n  const searchParams = new URLSearchParams(\n    Object.entries(params).flatMap(([key, value]) => {\n      // Search params should not include path params\n      if (pathParams.has(key)) {\n        return [];\n      } else if (Array.isArray(value)) {\n        return value.map((v) => [key, v]);\n      }\n      return [[key, value]];\n    })\n  );\n\n  let hash: string | undefined;\n  if (searchParams.has('#')) {\n    hash = searchParams.get('#') || undefined;\n    searchParams.delete('#');\n  }\n\n  // We cannot use searchParams.size because it is not included in the React Native polyfill\n  const searchParamString = searchParams.toString();\n  let pathnameWithParams = searchParamString ? pathname + '?' + searchParamString : pathname;\n  pathnameWithParams = hash ? pathnameWithParams + '#' + hash : pathnameWithParams;\n\n  return {\n    segments,\n    pathname,\n    params,\n    unstable_globalHref: appendBaseUrl(pathnameWithParams),\n    searchParams,\n    pathnameWithParams,\n    // TODO: Remove this, it is not used anywhere\n    isIndex: false,\n  };\n}\n\nfunction safeDecodeURIComponent(value: any) {\n  try {\n    return typeof value === 'string' ? decodeURIComponent(value) : value;\n  } catch {\n    // If the value is not a valid URI component, return it as is\n    return value;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}