{"ast":null,"code":"\"use strict\";\n\nvar _objectWithoutPropertiesLoose = require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\");\nconst _excluded = [\"preserveDynamicRoutes\", \"preserveGroups\", \"shouldEncodeURISegment\"],\n  _excluded2 = [\"#\"];\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function () {\n  var ownKeys = function (o) {\n    ownKeys = Object.getOwnPropertyNames || function (o) {\n      var ar = [];\n      for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n      return ar;\n    };\n    return ownKeys(o);\n  };\n  return function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n    __setModuleDefault(result, mod);\n    return result;\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getParamName = void 0;\nexports.validatePathConfig = validatePathConfig;\nexports.fixCurrentParams = fixCurrentParams;\nexports.appendQueryAndHash = appendQueryAndHash;\nexports.appendBaseUrl = appendBaseUrl;\nexports.getPathWithConventionsCollapsed = getPathWithConventionsCollapsed;\nexports.isDynamicPart = isDynamicPart;\nconst native_1 = require(\"@react-navigation/native\");\nconst queryString = __importStar(require(\"query-string\"));\nconst matchers_1 = require(\"../matchers\");\nfunction validatePathConfig(_ref) {\n  let options = _objectWithoutPropertiesLoose(_ref, _excluded);\n  (0, native_1.validatePathConfig)(options);\n}\nfunction fixCurrentParams(allParams, route, stringify) {\n  const currentParams = Object.fromEntries(Object.entries(route.params).flatMap(([key, value]) => {\n    if (key === 'screen' || key === 'params') {\n      return [];\n    }\n    return [[key, stringify?.[key] ? stringify[key](value) : Array.isArray(value) ? value.map(String) : String(value)]];\n  }));\n  Object.assign(allParams, currentParams);\n  return currentParams;\n}\nfunction appendQueryAndHash(path, _ref2) {\n  let {\n      '#': hash\n    } = _ref2,\n    focusedParams = _objectWithoutPropertiesLoose(_ref2, _excluded2);\n  const query = queryString.stringify(focusedParams, {\n    sort: false\n  });\n  if (query) {\n    path += `?${query}`;\n  }\n  if (hash) {\n    path += `#${hash}`;\n  }\n  return path;\n}\nfunction appendBaseUrl(path, baseUrl = \"\") {\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      return `/${baseUrl.replace(/^\\/+/, '').replace(/\\/$/, '')}${path}`;\n    }\n  }\n  return path;\n}\nfunction getPathWithConventionsCollapsed({\n  pattern,\n  route,\n  params,\n  preserveGroups,\n  preserveDynamicRoutes,\n  shouldEncodeURISegment = true,\n  initialRouteName\n}) {\n  const segments = pattern.split('/');\n  return segments.map((p, i) => {\n    const name = (0, exports.getParamName)(p);\n    if (p.startsWith('*')) {\n      if (preserveDynamicRoutes) {\n        if (name === 'not-found') {\n          return '+not-found';\n        }\n        return `[...${name}]`;\n      } else if (params[name]) {\n        if (Array.isArray(params[name])) {\n          return params[name].join('/');\n        }\n        return params[name];\n      } else if (route.name.startsWith('[') && route.name.endsWith(']')) {\n        return '';\n      } else if (p === '*not-found') {\n        return '';\n      } else {\n        return route.name;\n      }\n    }\n    if (p.startsWith(':')) {\n      if (preserveDynamicRoutes) {\n        return `[${name}]`;\n      }\n      const value = params[name];\n      if (value === undefined && p.endsWith('?')) {\n        return;\n      }\n      return (shouldEncodeURISegment ? encodeURISegment(value) : value) ?? 'undefined';\n    }\n    if (!preserveGroups && (0, matchers_1.matchGroupName)(p) != null) {\n      if (segments.length - 1 === i) {\n        if (initialRouteName) {\n          if (segmentMatchesConvention(initialRouteName)) {\n            return '';\n          }\n          return shouldEncodeURISegment ? encodeURISegment(initialRouteName, {\n            preserveBrackets: true\n          }) : initialRouteName;\n        }\n      }\n      return '';\n    }\n    return shouldEncodeURISegment ? encodeURISegment(p, {\n      preserveBrackets: true\n    }) : p;\n  }).map(v => v ?? '').join('/');\n}\nconst getParamName = pattern => pattern.replace(/^[:*]/, '').replace(/\\?$/, '');\nexports.getParamName = getParamName;\nfunction isDynamicPart(p) {\n  return p.startsWith(':') || p.startsWith('*');\n}\nfunction segmentMatchesConvention(segment) {\n  return segment === 'index' || (0, matchers_1.matchGroupName)(segment) != null || (0, matchers_1.matchDynamicName)(segment) != null;\n}\nfunction encodeURISegment(str, {\n  preserveBrackets = false\n} = {}) {\n  str = String(str).replace(/[^A-Za-z0-9\\-._~!$&'()*+,;=:@]/g, char => encodeURIComponent(char));\n  if (preserveBrackets) {\n    str = str.replace(/%5B/g, '[').replace(/%5D/g, ']');\n  }\n  return str;\n}","map":{"version":3,"names":["exports","validatePathConfig","fixCurrentParams","appendQueryAndHash","appendBaseUrl","getPathWithConventionsCollapsed","isDynamicPart","native_1","require","queryString","__importStar","matchers_1","_ref","options","_objectWithoutPropertiesLoose","_excluded","allParams","route","stringify","currentParams","Object","fromEntries","entries","params","flatMap","key","value","Array","isArray","map","String","assign","path","_ref2","hash","focusedParams","_excluded2","query","sort","baseUrl","process","env","NODE_ENV","replace","pattern","preserveGroups","preserveDynamicRoutes","shouldEncodeURISegment","initialRouteName","segments","split","p","i","name","getParamName","startsWith","join","endsWith","undefined","encodeURISegment","matchGroupName","length","segmentMatchesConvention","preserveBrackets","v","segment","matchDynamicName","str","char","encodeURIComponent"],"sources":["/Users/sbudhwar/workspace/github/tomanage/node_modules/expo-router/src/fork/getPathFromState-forks.ts"],"sourcesContent":["import { validatePathConfig as RNValidatePathConfig, type Route } from '@react-navigation/native';\nimport * as queryString from 'query-string';\n\nimport type { Options, State, StringifyConfig } from './getPathFromState';\nimport { matchDynamicName, matchGroupName } from '../matchers';\n\nexport type ExpoOptions = {\n  preserveDynamicRoutes?: boolean;\n  preserveGroups?: boolean;\n  shouldEncodeURISegment?: boolean;\n};\n\nexport type ExpoConfigItem = {\n  // Used as fallback for groups\n  initialRouteName?: string;\n};\n\nexport function validatePathConfig<ParamList extends object>({\n  preserveDynamicRoutes,\n  preserveGroups,\n  shouldEncodeURISegment,\n  ...options\n}: Options<ParamList>) {\n  RNValidatePathConfig(options);\n}\n\nexport function fixCurrentParams(\n  allParams: Record<string, any>,\n  route: Route<string> & {\n    state?: State;\n  },\n  stringify?: StringifyConfig\n) {\n  // Better handle array params\n  const currentParams = Object.fromEntries(\n    Object.entries(route.params!).flatMap(([key, value]) => {\n      if (key === 'screen' || key === 'params') {\n        return [];\n      }\n\n      return [\n        [\n          key,\n          stringify?.[key]\n            ? stringify[key](value)\n            : Array.isArray(value)\n              ? value.map(String)\n              : String(value),\n        ],\n      ];\n    })\n  );\n\n  // We always assign params, as non pattern routes may still have query params\n  Object.assign(allParams, currentParams);\n\n  return currentParams;\n}\n\nexport function appendQueryAndHash(\n  path: string,\n  { '#': hash, ...focusedParams }: Record<string, any>\n) {\n  const query = queryString.stringify(focusedParams, { sort: false });\n\n  if (query) {\n    path += `?${query}`;\n  }\n\n  if (hash) {\n    path += `#${hash}`;\n  }\n\n  return path;\n}\n\nexport function appendBaseUrl(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      return `/${baseUrl.replace(/^\\/+/, '').replace(/\\/$/, '')}${path}`;\n    }\n  }\n\n  return path;\n}\n\nexport function getPathWithConventionsCollapsed({\n  pattern,\n  route,\n  params,\n  preserveGroups,\n  preserveDynamicRoutes,\n  shouldEncodeURISegment = true,\n  initialRouteName,\n}: ExpoOptions & {\n  pattern: string;\n  route: Route<any>;\n  params: Record<string, any>;\n  initialRouteName?: string;\n}) {\n  const segments = pattern.split('/');\n\n  return segments\n    .map((p, i) => {\n      const name = getParamName(p);\n\n      // Showing the route name seems ok, though whatever we show here will be incorrect\n      // Since the page doesn't actually exist\n      if (p.startsWith('*')) {\n        if (preserveDynamicRoutes) {\n          if (name === 'not-found') {\n            return '+not-found';\n          }\n\n          return `[...${name}]`;\n        } else if (params[name]) {\n          if (Array.isArray(params[name])) {\n            return params[name].join('/');\n          }\n          return params[name];\n        } else if (route.name.startsWith('[') && route.name.endsWith(']')) {\n          return '';\n        } else if (p === '*not-found') {\n          return '';\n        } else {\n          return route.name;\n        }\n      }\n\n      // If the path has a pattern for a param, put the param in the path\n      if (p.startsWith(':')) {\n        if (preserveDynamicRoutes) {\n          return `[${name}]`;\n        }\n        // Optional params without value assigned in route.params should be ignored\n        const value = params[name];\n        if (value === undefined && p.endsWith('?')) {\n          return;\n        }\n\n        return (shouldEncodeURISegment ? encodeURISegment(value) : value) ?? 'undefined';\n      }\n\n      if (!preserveGroups && matchGroupName(p) != null) {\n        // When the last part is a group it could be a shared URL\n        // if the route has an initialRouteName defined, then we should\n        // use that as the component path as we can assume it will be shown.\n        if (segments.length - 1 === i) {\n          if (initialRouteName) {\n            // Return an empty string if the init route is ambiguous.\n            if (segmentMatchesConvention(initialRouteName)) {\n              return '';\n            }\n            return shouldEncodeURISegment\n              ? encodeURISegment(initialRouteName, { preserveBrackets: true })\n              : initialRouteName;\n          }\n        }\n        return '';\n      }\n      // Preserve dynamic syntax for rehydration\n      return shouldEncodeURISegment ? encodeURISegment(p, { preserveBrackets: true }) : p;\n    })\n    .map((v) => v ?? '')\n    .join('/');\n}\n\nexport const getParamName = (pattern: string) => pattern.replace(/^[:*]/, '').replace(/\\?$/, '');\n\nexport function isDynamicPart(p: string) {\n  return p.startsWith(':') || p.startsWith('*');\n}\n\nfunction segmentMatchesConvention(segment: string): boolean {\n  return (\n    segment === 'index' || matchGroupName(segment) != null || matchDynamicName(segment) != null\n  );\n}\n\nfunction encodeURISegment(str: string, { preserveBrackets = false } = {}) {\n  // Valid characters according to\n  // https://datatracker.ietf.org/doc/html/rfc3986#section-3.3 (see pchar definition)\n  str = String(str).replace(/[^A-Za-z0-9\\-._~!$&'()*+,;=:@]/g, (char) => encodeURIComponent(char));\n\n  if (preserveBrackets) {\n    // Preserve brackets\n    str = str.replace(/%5B/g, '[').replace(/%5D/g, ']');\n  }\n  return str;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}