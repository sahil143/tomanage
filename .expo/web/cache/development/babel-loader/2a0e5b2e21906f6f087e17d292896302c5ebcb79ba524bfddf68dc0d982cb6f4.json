{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseRouteSegments = parseRouteSegments;\nexports.getReactNavigationScreensConfig = getReactNavigationScreensConfig;\nexports.getReactNavigationConfig = getReactNavigationConfig;\nconst matchers_1 = require(\"./matchers\");\nfunction convertDynamicRouteToReactNavigation(segment) {\n  if (segment === 'index') {\n    return '';\n  }\n  if (segment === '+not-found') {\n    return '*not-found';\n  }\n  const dynamicName = (0, matchers_1.matchDynamicName)(segment);\n  if (dynamicName && !dynamicName.deep) {\n    return `:${dynamicName.name}`;\n  } else if (dynamicName?.deep) {\n    return '*' + dynamicName.name;\n  } else {\n    return segment;\n  }\n}\nfunction parseRouteSegments(segments) {\n  return (segments.split('/').map(convertDynamicRouteToReactNavigation).filter(Boolean).join('/')\n  );\n}\nfunction convertRouteNodeToScreen(node, metaOnly) {\n  const path = parseRouteSegments(node.route);\n  if (!node.children.length) {\n    if (!metaOnly) {\n      return {\n        path,\n        screens: {},\n        _route: node\n      };\n    }\n    return path;\n  }\n  const screens = getReactNavigationScreensConfig(node.children, metaOnly);\n  const screen = {\n    path,\n    screens\n  };\n  if (node.initialRouteName) {\n    screen.initialRouteName = node.initialRouteName;\n  }\n  if (!metaOnly) {\n    screen._route = node;\n  }\n  return screen;\n}\nfunction getReactNavigationScreensConfig(nodes, metaOnly) {\n  return Object.fromEntries(nodes.map(node => [node.route, convertRouteNodeToScreen(node, metaOnly)]));\n}\nfunction getReactNavigationConfig(routes, metaOnly) {\n  const config = {\n    initialRouteName: undefined,\n    screens: getReactNavigationScreensConfig(routes.children, metaOnly)\n  };\n  if (routes.initialRouteName) {\n    config.initialRouteName = routes.initialRouteName;\n  }\n  return config;\n}","map":{"version":3,"names":["exports","parseRouteSegments","getReactNavigationScreensConfig","getReactNavigationConfig","matchers_1","require","convertDynamicRouteToReactNavigation","segment","dynamicName","matchDynamicName","deep","name","segments","split","map","filter","Boolean","join","convertRouteNodeToScreen","node","metaOnly","path","route","children","length","screens","_route","screen","initialRouteName","nodes","Object","fromEntries","routes","config","undefined"],"sources":["/Users/sbudhwar/workspace/github/tomanage/node_modules/expo-router/src/getReactNavigationConfig.ts"],"sourcesContent":["import type { RouteNode } from './Route';\nimport { matchDynamicName } from './matchers';\n\nexport type Screen =\n  | string\n  | {\n      path: string;\n      screens: Record<string, Screen>;\n      _route?: RouteNode;\n      initialRouteName?: string;\n    };\n\n// `[page]` -> `:page`\n// `page` -> `page`\nfunction convertDynamicRouteToReactNavigation(segment: string): string {\n  // NOTE(EvanBacon): To support shared routes we preserve group segments.\n  if (segment === 'index') {\n    return '';\n  }\n  if (segment === '+not-found') {\n    return '*not-found';\n  }\n  const dynamicName = matchDynamicName(segment);\n  if (dynamicName && !dynamicName.deep) {\n    return `:${dynamicName.name}`;\n  } else if (dynamicName?.deep) {\n    return '*' + dynamicName.name;\n  } else {\n    return segment;\n  }\n}\n\nexport function parseRouteSegments(segments: string): string {\n  return (\n    // NOTE(EvanBacon): When there are nested routes without layouts\n    // the node.route will be something like `app/home/index`\n    // this needs to be split to ensure each segment is parsed correctly.\n    segments\n      .split('/')\n      // Convert each segment to a React Navigation format.\n      .map(convertDynamicRouteToReactNavigation)\n      // Remove any empty paths from groups or index routes.\n      .filter(Boolean)\n      // Join to return as a path.\n      .join('/')\n  );\n}\n\nfunction convertRouteNodeToScreen(node: RouteNode, metaOnly: boolean): Screen {\n  const path = parseRouteSegments(node.route);\n  if (!node.children.length) {\n    if (!metaOnly) {\n      return {\n        path,\n        screens: {},\n        _route: node,\n      };\n    }\n    return path;\n  }\n  const screens = getReactNavigationScreensConfig(node.children, metaOnly);\n\n  const screen: Screen = {\n    path,\n    screens,\n  };\n\n  if (node.initialRouteName) {\n    // NOTE(EvanBacon): This is bad because it forces all Layout Routes\n    // to be loaded into memory. We should move towards a system where\n    // the initial route name is either loaded asynchronously in the Layout Route\n    // or defined via a file system convention.\n    screen.initialRouteName = node.initialRouteName;\n  }\n\n  if (!metaOnly) {\n    screen._route = node;\n  }\n\n  return screen;\n}\n\nexport function getReactNavigationScreensConfig(\n  nodes: RouteNode[],\n  metaOnly: boolean\n): Record<string, Screen> {\n  return Object.fromEntries(\n    nodes.map((node) => [node.route, convertRouteNodeToScreen(node, metaOnly)] as const)\n  );\n}\n\nexport function getReactNavigationConfig(routes: RouteNode, metaOnly: boolean) {\n  const config = {\n    initialRouteName: undefined,\n    screens: getReactNavigationScreensConfig(routes.children, metaOnly),\n  };\n\n  if (routes.initialRouteName) {\n    // We're using LinkingOptions the generic type is `object` instead of a proper ParamList.\n    // So we need to cast the initialRouteName to `any` to avoid type errors.\n    config.initialRouteName = routes.initialRouteName as any;\n  }\n  return config;\n}\n"],"mappings":";;;;;AAgCAA,OAAA,CAAAC,kBAAA,GAAAA,kBAAA;AAkDAD,OAAA,CAAAE,+BAAA,GAAAA,+BAAA;AASAF,OAAA,CAAAG,wBAAA,GAAAA,wBAAA;AA1FA,MAAAC,UAAA,GAAAC,OAAA;AAaA,SAASC,oCAAoCA,CAACC,OAAe;EAE3D,IAAIA,OAAO,KAAK,OAAO,EAAE;IACvB,OAAO,EAAE;EACX;EACA,IAAIA,OAAO,KAAK,YAAY,EAAE;IAC5B,OAAO,YAAY;EACrB;EACA,MAAMC,WAAW,GAAG,IAAAJ,UAAA,CAAAK,gBAAgB,EAACF,OAAO,CAAC;EAC7C,IAAIC,WAAW,IAAI,CAACA,WAAW,CAACE,IAAI,EAAE;IACpC,OAAO,IAAIF,WAAW,CAACG,IAAI,EAAE;EAC/B,CAAC,MAAM,IAAIH,WAAW,EAAEE,IAAI,EAAE;IAC5B,OAAO,GAAG,GAAGF,WAAW,CAACG,IAAI;EAC/B,CAAC,MAAM;IACL,OAAOJ,OAAO;EAChB;AACF;AAEA,SAAgBN,kBAAkBA,CAACW,QAAgB;EACjD,QAIEA,QAAQ,CACLC,KAAK,CAAC,GAAG,CAAC,CAEVC,GAAG,CAACR,oCAAoC,CAAC,CAEzCS,MAAM,CAACC,OAAO,CAAC,CAEfC,IAAI,CAAC,GAAG;EAAC;AAEhB;AAEA,SAASC,wBAAwBA,CAACC,IAAe,EAAEC,QAAiB;EAClE,MAAMC,IAAI,GAAGpB,kBAAkB,CAACkB,IAAI,CAACG,KAAK,CAAC;EAC3C,IAAI,CAACH,IAAI,CAACI,QAAQ,CAACC,MAAM,EAAE;IACzB,IAAI,CAACJ,QAAQ,EAAE;MACb,OAAO;QACLC,IAAI;QACJI,OAAO,EAAE,EAAE;QACXC,MAAM,EAAEP;OACT;IACH;IACA,OAAOE,IAAI;EACb;EACA,MAAMI,OAAO,GAAGvB,+BAA+B,CAACiB,IAAI,CAACI,QAAQ,EAAEH,QAAQ,CAAC;EAExE,MAAMO,MAAM,GAAW;IACrBN,IAAI;IACJI;GACD;EAED,IAAIN,IAAI,CAACS,gBAAgB,EAAE;IAKzBD,MAAM,CAACC,gBAAgB,GAAGT,IAAI,CAACS,gBAAgB;EACjD;EAEA,IAAI,CAACR,QAAQ,EAAE;IACbO,MAAM,CAACD,MAAM,GAAGP,IAAI;EACtB;EAEA,OAAOQ,MAAM;AACf;AAEA,SAAgBzB,+BAA+BA,CAC7C2B,KAAkB,EAClBT,QAAiB;EAEjB,OAAOU,MAAM,CAACC,WAAW,CACvBF,KAAK,CAACf,GAAG,CAAEK,IAAI,IAAK,CAACA,IAAI,CAACG,KAAK,EAAEJ,wBAAwB,CAACC,IAAI,EAAEC,QAAQ,CAAC,CAAU,CAAC,CACrF;AACH;AAEA,SAAgBjB,wBAAwBA,CAAC6B,MAAiB,EAAEZ,QAAiB;EAC3E,MAAMa,MAAM,GAAG;IACbL,gBAAgB,EAAEM,SAAS;IAC3BT,OAAO,EAAEvB,+BAA+B,CAAC8B,MAAM,CAACT,QAAQ,EAAEH,QAAQ;GACnE;EAED,IAAIY,MAAM,CAACJ,gBAAgB,EAAE;IAG3BK,MAAM,CAACL,gBAAgB,GAAGI,MAAM,CAACJ,gBAAuB;EAC1D;EACA,OAAOK,MAAM;AACf","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}