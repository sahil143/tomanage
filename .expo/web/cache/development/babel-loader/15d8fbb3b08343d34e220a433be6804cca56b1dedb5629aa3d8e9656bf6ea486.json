{"ast":null,"code":"import parseErrorStack from '../modules/parseErrorStack';\nimport stringifySafe from '../modules/stringifySafe';\nconst BABEL_TRANSFORM_ERROR_FORMAT = /^(?:TransformError )?(?:SyntaxError: |ReferenceError: )(.*): (.*) \\((\\d+):(\\d+)\\)\\n\\n([\\s\\S]+)/;\nconst BABEL_CODE_FRAME_ERROR_FORMAT = /^(?:TransformError )?(?:.*):? (?:.*?)([/|\\\\].*): ([\\s\\S]+?)\\n([ >]{2}[\\d\\s]+ \\|[\\s\\S]+|\\u{001b}[\\s\\S]+)/u;\nconst METRO_ERROR_FORMAT = /^(?:InternalError Metro has encountered an error:) (.*): (.*) \\((\\d+):(\\d+)\\)\\n\\n([\\s\\S]+)/u;\nconst SUBSTITUTION = '\\ufeff%s';\nexport function parseInterpolation(args) {\n  const categoryParts = [];\n  const contentParts = [];\n  const substitutionOffsets = [];\n  const remaining = [...args];\n  if (typeof remaining[0] === 'string') {\n    const formatString = String(remaining.shift());\n    const formatStringParts = formatString.split('%s');\n    const substitutionCount = formatStringParts.length - 1;\n    const substitutions = remaining.splice(0, substitutionCount);\n    let categoryString = '';\n    let contentString = '';\n    let substitutionIndex = 0;\n    for (const formatStringPart of formatStringParts) {\n      categoryString += formatStringPart;\n      contentString += formatStringPart;\n      if (substitutionIndex < substitutionCount) {\n        if (substitutionIndex < substitutions.length) {\n          const substitution = typeof substitutions[substitutionIndex] === 'string' ? substitutions[substitutionIndex] : stringifySafe(substitutions[substitutionIndex]);\n          substitutionOffsets.push({\n            length: substitution.length,\n            offset: contentString.length\n          });\n          categoryString += SUBSTITUTION;\n          contentString += substitution;\n        } else {\n          substitutionOffsets.push({\n            length: 2,\n            offset: contentString.length\n          });\n          categoryString += '%s';\n          contentString += '%s';\n        }\n        substitutionIndex++;\n      }\n    }\n    categoryParts.push(categoryString);\n    contentParts.push(contentString);\n  }\n  const remainingArgs = remaining.map(arg => {\n    return typeof arg === 'string' ? arg : stringifySafe(arg);\n  });\n  categoryParts.push(...remainingArgs);\n  contentParts.push(...remainingArgs);\n  return {\n    category: categoryParts.join(' '),\n    message: {\n      content: contentParts.join(' '),\n      substitutions: substitutionOffsets\n    }\n  };\n}\nfunction isComponentStack(consoleArgument) {\n  const isOldComponentStackFormat = / {4}in/.test(consoleArgument);\n  const isNewComponentStackFormat = / {4}at/.test(consoleArgument);\n  const isNewJSCComponentStackFormat = /@.*\\n/.test(consoleArgument);\n  return isOldComponentStackFormat || isNewComponentStackFormat || isNewJSCComponentStackFormat;\n}\nexport function parseComponentStack(message) {\n  const stack = parseErrorStack(message);\n  if (stack && stack.length > 0) {\n    return stack.map(frame => ({\n      content: frame.methodName,\n      collapse: frame.collapse || false,\n      fileName: frame.file == null ? 'unknown' : frame.file,\n      location: {\n        column: frame.column == null ? -1 : frame.column,\n        row: frame.lineNumber == null ? -1 : frame.lineNumber\n      }\n    }));\n  }\n  return message.split(/\\n {4}in /g).map(s => {\n    if (!s) {\n      return null;\n    }\n    const match = s.match(/(.*) \\(at (.*\\.js):([\\d]+)\\)/);\n    if (!match) {\n      return null;\n    }\n    const [content, fileName, row] = match.slice(1);\n    return {\n      content,\n      fileName,\n      location: {\n        column: -1,\n        row: parseInt(row, 10)\n      }\n    };\n  }).filter(Boolean);\n}\nexport function parseLogBoxException(error) {\n  const message = error.originalMessage != null ? error.originalMessage : 'Unknown';\n  const metroInternalError = message.match(METRO_ERROR_FORMAT);\n  if (metroInternalError) {\n    const [content, fileName, row, column, codeFrame] = metroInternalError.slice(1);\n    return {\n      level: 'fatal',\n      type: 'Metro Error',\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName,\n        location: {\n          row: parseInt(row, 10),\n          column: parseInt(column, 10)\n        },\n        content: codeFrame\n      },\n      message: {\n        content,\n        substitutions: []\n      },\n      category: `${fileName}-${row}-${column}`\n    };\n  }\n  const babelTransformError = message.match(BABEL_TRANSFORM_ERROR_FORMAT);\n  if (babelTransformError) {\n    const [fileName, content, row, column, codeFrame] = babelTransformError.slice(1);\n    return {\n      level: 'syntax',\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName,\n        location: {\n          row: parseInt(row, 10),\n          column: parseInt(column, 10)\n        },\n        content: codeFrame\n      },\n      message: {\n        content,\n        substitutions: []\n      },\n      category: `${fileName}-${row}-${column}`\n    };\n  }\n  const babelCodeFrameError = message.match(BABEL_CODE_FRAME_ERROR_FORMAT);\n  if (babelCodeFrameError) {\n    const [fileName, content, codeFrame] = babelCodeFrameError.slice(1);\n    return {\n      level: 'syntax',\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName,\n        location: null,\n        content: codeFrame\n      },\n      message: {\n        content,\n        substitutions: []\n      },\n      category: `${fileName}-${1}-${1}`\n    };\n  }\n  if (message.match(/^TransformError /)) {\n    return {\n      level: 'syntax',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack: [],\n      message: {\n        content: message,\n        substitutions: []\n      },\n      category: message\n    };\n  }\n  const componentStack = error.componentStack;\n  if (error.isFatal || error.isComponentError) {\n    return Object.assign({\n      level: 'fatal',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack: componentStack != null ? parseComponentStack(componentStack) : []\n    }, parseInterpolation([message]));\n  }\n  if (componentStack != null) {\n    return Object.assign({\n      level: 'error',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack: parseComponentStack(componentStack)\n    }, parseInterpolation([message]));\n  }\n  return Object.assign({\n    level: 'error',\n    stack: error.stack,\n    isComponentError: error.isComponentError\n  }, parseLogBoxLog([message]));\n}\nexport function parseLogBoxLog(args) {\n  const message = args[0];\n  let argsWithoutComponentStack = [];\n  let componentStack = [];\n  if (typeof message === 'string' && message.slice(-2) === '%s' && args.length > 0) {\n    const lastArg = args[args.length - 1];\n    if (typeof lastArg === 'string' && isComponentStack(lastArg)) {\n      argsWithoutComponentStack = args.slice(0, -1);\n      argsWithoutComponentStack[0] = message.slice(0, -2);\n      componentStack = parseComponentStack(lastArg);\n    }\n  }\n  if (componentStack.length === 0) {\n    for (const arg of args) {\n      if (typeof arg === 'string' && isComponentStack(arg)) {\n        let messageEndIndex = arg.search(/\\n {4}(in|at) /);\n        if (messageEndIndex < 0) {\n          messageEndIndex = arg.search(/\\n/);\n        }\n        if (messageEndIndex > 0) {\n          argsWithoutComponentStack.push(arg.slice(0, messageEndIndex));\n        }\n        componentStack = parseComponentStack(arg);\n      } else {\n        argsWithoutComponentStack.push(arg);\n      }\n    }\n  }\n  return Object.assign({}, parseInterpolation(argsWithoutComponentStack), {\n    componentStack\n  });\n}","map":{"version":3,"names":["parseErrorStack","stringifySafe","BABEL_TRANSFORM_ERROR_FORMAT","BABEL_CODE_FRAME_ERROR_FORMAT","METRO_ERROR_FORMAT","SUBSTITUTION","parseInterpolation","args","categoryParts","contentParts","substitutionOffsets","remaining","formatString","String","shift","formatStringParts","split","substitutionCount","length","substitutions","splice","categoryString","contentString","substitutionIndex","formatStringPart","substitution","push","offset","remainingArgs","map","arg","category","join","message","content","isComponentStack","consoleArgument","isOldComponentStackFormat","test","isNewComponentStackFormat","isNewJSCComponentStackFormat","parseComponentStack","stack","frame","methodName","collapse","fileName","file","location","column","row","lineNumber","s","match","slice","parseInt","filter","Boolean","parseLogBoxException","error","originalMessage","metroInternalError","codeFrame","level","type","isComponentError","componentStack","babelTransformError","babelCodeFrameError","isFatal","Object","assign","parseLogBoxLog","argsWithoutComponentStack","lastArg","messageEndIndex","search"],"sources":["/Users/sbudhwar/workspace/github/tomanage/node_modules/@expo/metro-runtime/src/error-overlay/Data/parseLogBoxLog.tsx"],"sourcesContent":["/**\n * Copyright (c) 650 Industries.\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type { LogBoxLogData } from './LogBoxLog';\nimport parseErrorStack from '../modules/parseErrorStack';\nimport stringifySafe from '../modules/stringifySafe';\ntype ExceptionData = any;\n\nconst BABEL_TRANSFORM_ERROR_FORMAT =\n  /^(?:TransformError )?(?:SyntaxError: |ReferenceError: )(.*): (.*) \\((\\d+):(\\d+)\\)\\n\\n([\\s\\S]+)/;\nconst BABEL_CODE_FRAME_ERROR_FORMAT =\n  /^(?:TransformError )?(?:.*):? (?:.*?)([/|\\\\].*): ([\\s\\S]+?)\\n([ >]{2}[\\d\\s]+ \\|[\\s\\S]+|\\u{001b}[\\s\\S]+)/u;\nconst METRO_ERROR_FORMAT =\n  /^(?:InternalError Metro has encountered an error:) (.*): (.*) \\((\\d+):(\\d+)\\)\\n\\n([\\s\\S]+)/u;\n\nexport type ExtendedExceptionData = ExceptionData & {\n  isComponentError: boolean;\n  [key: string]: any;\n};\nexport type Category = string;\nexport type CodeFrame = {\n  content: string;\n  location?: {\n    row: number;\n    column: number;\n    [key: string]: any;\n  } | null;\n  fileName: string;\n\n  // TODO: When React switched to using call stack frames,\n  // we gained the ability to use the collapse flag, but\n  // it is not integrated into the LogBox UI.\n  collapse?: boolean;\n};\n\nexport type Message = {\n  content: string;\n  substitutions: {\n    length: number;\n    offset: number;\n  }[];\n};\n\nexport type ComponentStack = CodeFrame[];\n\nconst SUBSTITUTION = '\\ufeff%s';\n\nexport function parseInterpolation(args: readonly any[]): {\n  category: Category;\n  message: Message;\n} {\n  const categoryParts: string[] = [];\n  const contentParts: string[] = [];\n  const substitutionOffsets: { length: number; offset: number }[] = [];\n\n  const remaining = [...args];\n  if (typeof remaining[0] === 'string') {\n    const formatString = String(remaining.shift());\n    const formatStringParts = formatString.split('%s');\n    const substitutionCount = formatStringParts.length - 1;\n    const substitutions = remaining.splice(0, substitutionCount);\n\n    let categoryString = '';\n    let contentString = '';\n\n    let substitutionIndex = 0;\n    for (const formatStringPart of formatStringParts) {\n      categoryString += formatStringPart;\n      contentString += formatStringPart;\n\n      if (substitutionIndex < substitutionCount) {\n        if (substitutionIndex < substitutions.length) {\n          // Don't stringify a string type.\n          // It adds quotation mark wrappers around the string,\n          // which causes the LogBox to look odd.\n          const substitution =\n            typeof substitutions[substitutionIndex] === 'string'\n              ? substitutions[substitutionIndex]\n              : stringifySafe(substitutions[substitutionIndex]);\n          substitutionOffsets.push({\n            length: substitution.length,\n            offset: contentString.length,\n          });\n\n          categoryString += SUBSTITUTION;\n          contentString += substitution;\n        } else {\n          substitutionOffsets.push({\n            length: 2,\n            offset: contentString.length,\n          });\n\n          categoryString += '%s';\n          contentString += '%s';\n        }\n\n        substitutionIndex++;\n      }\n    }\n\n    categoryParts.push(categoryString);\n    contentParts.push(contentString);\n  }\n\n  const remainingArgs = remaining.map((arg) => {\n    // Don't stringify a string type.\n    // It adds quotation mark wrappers around the string,\n    // which causes the LogBox to look odd.\n    return typeof arg === 'string' ? arg : stringifySafe(arg);\n  });\n  categoryParts.push(...remainingArgs);\n  contentParts.push(...remainingArgs);\n\n  return {\n    category: categoryParts.join(' '),\n    message: {\n      content: contentParts.join(' '),\n      substitutions: substitutionOffsets,\n    },\n  };\n}\n\nfunction isComponentStack(consoleArgument: string) {\n  const isOldComponentStackFormat = / {4}in/.test(consoleArgument);\n  const isNewComponentStackFormat = / {4}at/.test(consoleArgument);\n  const isNewJSCComponentStackFormat = /@.*\\n/.test(consoleArgument);\n\n  return isOldComponentStackFormat || isNewComponentStackFormat || isNewJSCComponentStackFormat;\n}\n\nexport function parseComponentStack(message: string): ComponentStack {\n  // In newer versions of React, the component stack is formatted as a call stack frame.\n  // First try to parse the component stack as a call stack frame, and if that doesn't\n  // work then we'll fallback to the old custom component stack format parsing.\n  const stack = parseErrorStack(message);\n  if (stack && stack.length > 0) {\n    return stack.map((frame) => ({\n      content: frame.methodName,\n      collapse: frame.collapse || false,\n      fileName: frame.file == null ? 'unknown' : frame.file,\n      location: {\n        column: frame.column == null ? -1 : frame.column,\n        row: frame.lineNumber == null ? -1 : frame.lineNumber,\n      },\n    }));\n  }\n\n  return message\n    .split(/\\n {4}in /g)\n    .map((s) => {\n      if (!s) {\n        return null;\n      }\n      const match = s.match(/(.*) \\(at (.*\\.js):([\\d]+)\\)/);\n      if (!match) {\n        return null;\n      }\n\n      const [content, fileName, row] = match.slice(1);\n      return {\n        content,\n        fileName,\n        location: { column: -1, row: parseInt(row, 10) },\n      };\n    })\n    .filter(Boolean) as ComponentStack;\n}\n\nexport function parseLogBoxException(error: ExtendedExceptionData): LogBoxLogData {\n  const message = error.originalMessage != null ? error.originalMessage : 'Unknown';\n\n  const metroInternalError = message.match(METRO_ERROR_FORMAT);\n  if (metroInternalError) {\n    const [content, fileName, row, column, codeFrame] = metroInternalError.slice(1);\n\n    return {\n      level: 'fatal',\n      type: 'Metro Error',\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName,\n        location: {\n          row: parseInt(row, 10),\n          column: parseInt(column, 10),\n        },\n        content: codeFrame,\n      },\n      message: {\n        content,\n        substitutions: [],\n      },\n      category: `${fileName}-${row}-${column}`,\n    };\n  }\n\n  const babelTransformError = message.match(BABEL_TRANSFORM_ERROR_FORMAT);\n  if (babelTransformError) {\n    // Transform errors are thrown from inside the Babel transformer.\n    const [fileName, content, row, column, codeFrame] = babelTransformError.slice(1);\n\n    return {\n      level: 'syntax',\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName,\n        location: {\n          row: parseInt(row, 10),\n          column: parseInt(column, 10),\n        },\n        content: codeFrame,\n      },\n      message: {\n        content,\n        substitutions: [],\n      },\n      category: `${fileName}-${row}-${column}`,\n    };\n  }\n\n  const babelCodeFrameError = message.match(BABEL_CODE_FRAME_ERROR_FORMAT);\n\n  if (babelCodeFrameError) {\n    // Codeframe errors are thrown from any use of buildCodeFrameError.\n    const [fileName, content, codeFrame] = babelCodeFrameError.slice(1);\n    return {\n      level: 'syntax',\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName,\n        location: null, // We are not given the location.\n        content: codeFrame,\n      },\n      message: {\n        content,\n        substitutions: [],\n      },\n      category: `${fileName}-${1}-${1}`,\n    };\n  }\n\n  if (message.match(/^TransformError /)) {\n    return {\n      level: 'syntax',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack: [],\n      message: {\n        content: message,\n        substitutions: [],\n      },\n      category: message,\n    };\n  }\n\n  const componentStack = error.componentStack;\n  if (error.isFatal || error.isComponentError) {\n    return {\n      level: 'fatal',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack: componentStack != null ? parseComponentStack(componentStack) : [],\n      ...parseInterpolation([message]),\n    };\n  }\n\n  if (componentStack != null) {\n    // It is possible that console errors have a componentStack.\n    return {\n      level: 'error',\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack: parseComponentStack(componentStack),\n      ...parseInterpolation([message]),\n    };\n  }\n\n  // Most `console.error` calls won't have a componentStack. We parse them like\n  // regular logs which have the component stack burried in the message.\n  return {\n    level: 'error',\n    stack: error.stack,\n    isComponentError: error.isComponentError,\n    ...parseLogBoxLog([message]),\n  };\n}\n\nexport function parseLogBoxLog(args: readonly any[]): {\n  componentStack: ComponentStack;\n  category: Category;\n  message: Message;\n} {\n  const message = args[0];\n  let argsWithoutComponentStack: any[] = [];\n  let componentStack: ComponentStack = [];\n\n  // Extract component stack from warnings like \"Some warning%s\".\n  if (typeof message === 'string' && message.slice(-2) === '%s' && args.length > 0) {\n    const lastArg = args[args.length - 1];\n    if (typeof lastArg === 'string' && isComponentStack(lastArg)) {\n      argsWithoutComponentStack = args.slice(0, -1);\n      argsWithoutComponentStack[0] = message.slice(0, -2);\n      componentStack = parseComponentStack(lastArg);\n    }\n  }\n\n  if (componentStack.length === 0) {\n    // Try finding the component stack elsewhere.\n    for (const arg of args) {\n      if (typeof arg === 'string' && isComponentStack(arg)) {\n        // Strip out any messages before the component stack.\n        let messageEndIndex = arg.search(/\\n {4}(in|at) /);\n        if (messageEndIndex < 0) {\n          // Handle JSC component stacks.\n          messageEndIndex = arg.search(/\\n/);\n        }\n        if (messageEndIndex > 0) {\n          argsWithoutComponentStack.push(arg.slice(0, messageEndIndex));\n        }\n\n        componentStack = parseComponentStack(arg);\n      } else {\n        argsWithoutComponentStack.push(arg);\n      }\n    }\n  }\n\n  return {\n    ...parseInterpolation(argsWithoutComponentStack),\n    componentStack,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}