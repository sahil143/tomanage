{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getRoutes = getRoutes;\nexports.extrapolateGroups = extrapolateGroups;\nexports.generateDynamic = generateDynamic;\nconst matchers_1 = require(\"./matchers\");\nconst url_1 = require(\"./utils/url\");\nconst validPlatforms = new Set(['android', 'ios', 'native', 'web']);\nfunction getRoutes(contextModule, options) {\n  const middleware = getMiddleware(contextModule, options);\n  const directoryTree = getDirectoryTree(contextModule, options);\n  if (!directoryTree) {\n    return null;\n  }\n  const rootNode = flattenDirectoryTreeToRoutes(directoryTree, options);\n  if (middleware) {\n    rootNode.middleware = middleware;\n  }\n  if (!options.ignoreEntryPoints) {\n    crawlAndAppendInitialRoutesAndEntryFiles(rootNode, options);\n  }\n  return rootNode;\n}\nfunction getMiddleware(contextModule, options) {\n  const allMiddlewareFiles = contextModule.keys().filter(key => key.includes('+middleware'));\n  if (!options.unstable_useServerMiddleware) {\n    if (allMiddlewareFiles.length > 0) {\n      console.warn('Server middleware is not enabled. Add unstable_useServerMiddleware: true to your `expo-router` plugin config.\\n\\n' + JSON.stringify({\n        expo: {\n          plugins: [['expo-router', {\n            unstable_useServerMiddleware: true\n          }]]\n        }\n      }, null, 2));\n    }\n    return null;\n  }\n  const isValidMiddleware = key => /^\\.\\/\\+middleware\\.[tj]sx?$/.test(key);\n  const rootMiddlewareFiles = allMiddlewareFiles.filter(isValidMiddleware);\n  const nonRootMiddleware = allMiddlewareFiles.filter(file => !rootMiddlewareFiles.includes(file));\n  if (nonRootMiddleware.length > 0) {\n    throw new Error(`The middleware file can only be placed at the root level. Remove the following files: ${nonRootMiddleware.join(', ')}`);\n  }\n  if (rootMiddlewareFiles.length === 0) {\n    return null;\n  }\n  if (rootMiddlewareFiles.length > 1) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(`Only one middleware file is allowed. Keep one of the conflicting files: ${rootMiddlewareFiles.map(p => `\"${p}\"`).join(' or ')}`);\n    }\n  }\n  const middlewareFilePath = rootMiddlewareFiles[0];\n  const middleware = {\n    loadRoute() {\n      if (options.ignoreRequireErrors) {\n        try {\n          return contextModule(middlewareFilePath);\n        } catch {\n          return {};\n        }\n      } else {\n        return contextModule(middlewareFilePath);\n      }\n    },\n    contextKey: middlewareFilePath\n  };\n  if (options.internal_stripLoadRoute) {\n    delete middleware.loadRoute;\n  }\n  return middleware;\n}\nfunction getDirectoryTree(contextModule, options) {\n  const importMode = options.importMode || \"sync\";\n  const ignoreList = [/^\\.\\/\\+(html|native-intent)\\.[tj]sx?$/];\n  if (options.ignore) {\n    ignoreList.push(...options.ignore);\n  }\n  if (!options.preserveApiRoutes) {\n    ignoreList.push(/\\+api$/, /\\+api\\.[tj]sx?$/);\n  }\n  ignoreList.push(/\\+middleware$/, /\\+middleware\\.[tj]sx?$/);\n  const rootDirectory = {\n    files: new Map(),\n    subdirectories: new Map()\n  };\n  let hasRoutes = false;\n  let isValid = false;\n  const contextKeys = contextModule.keys();\n  const redirects = {};\n  const rewrites = {};\n  let validRedirectDestinations;\n  const getValidDestinations = () => {\n    validRedirectDestinations ??= contextKeys.map(key => {\n      return {\n        contextKey: key,\n        nameWithoutInvisible: getNameWithoutInvisibleSegmentsFromRedirectPath((0, matchers_1.removeSupportedExtensions)(key))\n      };\n    });\n    return validRedirectDestinations;\n  };\n  if (options.preserveRedirectAndRewrites) {\n    if (options.redirects) {\n      for (const redirect of options.redirects) {\n        const sourceContextKey = getSourceContextKeyFromRedirectSource(redirect.source);\n        const sourceName = getNameFromRedirectPath(redirect.source);\n        const isExternalRedirect = (0, url_1.shouldLinkExternally)(redirect.destination);\n        const targetDestinationName = isExternalRedirect ? redirect.destination : getNameWithoutInvisibleSegmentsFromRedirectPath(redirect.destination);\n        if (ignoreList.some(regex => regex.test(sourceContextKey))) {\n          continue;\n        }\n        const validDestination = isExternalRedirect ? undefined : getValidDestinations().find(key => key.nameWithoutInvisible === targetDestinationName);\n        const destination = isExternalRedirect ? targetDestinationName : validDestination?.nameWithoutInvisible;\n        const destinationContextKey = isExternalRedirect ? targetDestinationName : validDestination?.contextKey;\n        if (!destinationContextKey || destination === undefined) {\n          if (options.preserveApiRoutes) {\n            throw new Error(`Redirect destination \"${redirect.destination}\" does not exist.`);\n          }\n          continue;\n        }\n        contextKeys.push(sourceContextKey);\n        redirects[sourceName] = {\n          source: sourceName,\n          destination,\n          destinationContextKey,\n          permanent: Boolean(redirect.permanent),\n          external: isExternalRedirect,\n          methods: redirect.methods\n        };\n      }\n    }\n    if (options.rewrites) {\n      for (const rewrite of options.rewrites) {\n        const sourceContextKey = getSourceContextKeyFromRedirectSource(rewrite.source);\n        const sourceName = getNameFromRedirectPath(rewrite.source);\n        const isSourceContextKeyAlreadyKnown = contextKeys.includes(sourceContextKey);\n        const targetDestinationName = isSourceContextKeyAlreadyKnown ? getNameFromRedirectPath(rewrite.destination) : getNameWithoutInvisibleSegmentsFromRedirectPath(rewrite.destination);\n        if (ignoreList.some(regex => regex.test(sourceContextKey))) {\n          continue;\n        }\n        const validDestination = getValidDestinations().find(key => key.nameWithoutInvisible === targetDestinationName);\n        const destination = validDestination?.nameWithoutInvisible;\n        const destinationContextKey = validDestination?.contextKey;\n        if (!destinationContextKey || destination === undefined) {\n          if (options.preserveApiRoutes) {\n            throw new Error(`Rewrite destination \"${rewrite.destination}\" does not exist.`);\n          }\n          continue;\n        }\n        contextKeys.push(sourceContextKey);\n        rewrites[sourceName] = {\n          source: sourceName,\n          destination,\n          destinationContextKey,\n          methods: rewrite.methods\n        };\n      }\n    }\n  }\n  const processedRedirectsRewrites = new Set();\n  for (const filePath of contextKeys) {\n    if (ignoreList.some(regex => regex.test(filePath))) {\n      continue;\n    }\n    isValid = true;\n    const meta = getFileMeta(filePath, options, redirects, rewrites);\n    if (meta.specificity < 0) {\n      continue;\n    }\n    let node = {\n      type: meta.isApi ? 'api' : meta.isLayout ? 'layout' : 'route',\n      loadRoute() {\n        let routeModule;\n        if (options.ignoreRequireErrors) {\n          try {\n            routeModule = contextModule(filePath);\n          } catch {\n            routeModule = {};\n          }\n        } else {\n          routeModule = contextModule(filePath);\n        }\n        if (process.env.NODE_ENV === 'development' && importMode === 'sync') {\n          if (routeModule instanceof Promise) {\n            throw new Error(`Route \"${filePath}\" cannot be a promise when async routes is disabled.`);\n          }\n          const defaultExport = routeModule?.default;\n          if (defaultExport instanceof Promise) {\n            throw new Error(`The default export from route \"${filePath}\" is a promise. Ensure the React Component does not use async or promises.`);\n          }\n          if (defaultExport instanceof Function && defaultExport.constructor.name === 'AsyncFunction') {\n            throw new Error(`The default export from route \"${filePath}\" is an async function. Ensure the React Component does not use async or promises.`);\n          }\n        }\n        return routeModule;\n      },\n      contextKey: filePath,\n      route: '',\n      dynamic: null,\n      children: []\n    };\n    if (meta.isRedirect) {\n      if (processedRedirectsRewrites.has(meta.route)) {\n        continue;\n      }\n      const redirect = redirects[meta.route];\n      node.destinationContextKey = redirect.destinationContextKey;\n      node.permanent = redirect.permanent;\n      node.generated = true;\n      if (node.type === 'route') {\n        node = options.getSystemRoute({\n          type: 'redirect',\n          route: redirect.destination,\n          defaults: node,\n          redirectConfig: redirect\n        });\n      }\n      if (redirect.methods) {\n        node.methods = redirect.methods;\n      }\n      node.type = 'redirect';\n      processedRedirectsRewrites.add(meta.route);\n    }\n    if (meta.isRewrite) {\n      if (processedRedirectsRewrites.has(meta.route)) {\n        continue;\n      }\n      const rewrite = rewrites[meta.route];\n      node.destinationContextKey = rewrite.destinationContextKey;\n      node.generated = true;\n      if (node.type === 'route') {\n        node = options.getSystemRoute({\n          type: 'rewrite',\n          route: rewrite.destination,\n          defaults: node,\n          rewriteConfig: rewrite\n        });\n      }\n      if (rewrite.methods) {\n        node.methods = rewrite.methods;\n      }\n      node.type = 'rewrite';\n      processedRedirectsRewrites.add(meta.route);\n    }\n    if (process.env.NODE_ENV === 'development') {\n      if (node.type !== 'api' && importMode === 'sync') {\n        const routeItem = node.loadRoute();\n        const route = routeItem?.default;\n        if (route == null) {\n          console.warn(`Route \"${filePath}\" is missing the required default export. Ensure a React component is exported as default.`);\n          continue;\n        }\n        if (['boolean', 'number', 'string'].includes(typeof route)) {\n          throw new Error(`The default export from route \"${filePath}\" is an unsupported type: \"${typeof route}\". Only React Components are supported as default exports from route files.`);\n        }\n      }\n    }\n    for (const route of extrapolateGroups(meta.route)) {\n      const subdirectoryParts = route.split('/').slice(0, -1);\n      let directory = rootDirectory;\n      for (const part of subdirectoryParts) {\n        let subDirectory = directory.subdirectories.get(part);\n        if (!subDirectory) {\n          subDirectory = {\n            files: new Map(),\n            subdirectories: new Map()\n          };\n          directory.subdirectories.set(part, subDirectory);\n        }\n        directory = subDirectory;\n      }\n      node = Object.assign({}, node, {\n        route\n      });\n      if (meta.isLayout) {\n        directory.layout ??= [];\n        const existing = directory.layout[meta.specificity];\n        if (existing) {\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(`The layouts \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Remove or rename one of these files.`);\n          }\n        } else {\n          node = getLayoutNode(node, options);\n          directory.layout[meta.specificity] = node;\n        }\n      } else if (meta.isApi) {\n        const fileKey = `${route}+api`;\n        let nodes = directory.files.get(fileKey);\n        if (!nodes) {\n          nodes = [];\n          directory.files.set(fileKey, nodes);\n        }\n        const existing = nodes[0];\n        if (existing) {\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(`The API route file \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Remove or rename one of these files.`);\n          }\n        } else {\n          nodes[0] = node;\n        }\n      } else {\n        let nodes = directory.files.get(route);\n        if (!nodes) {\n          nodes = [];\n          directory.files.set(route, nodes);\n        }\n        const existing = nodes[meta.specificity];\n        if (existing) {\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(`The route files \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Remove or rename one of these files.`);\n          }\n        } else {\n          hasRoutes ||= true;\n          nodes[meta.specificity] = node;\n        }\n      }\n    }\n  }\n  if (!isValid) {\n    return null;\n  }\n  if (!rootDirectory.layout) {\n    rootDirectory.layout = [options.getSystemRoute({\n      type: 'layout',\n      route: ''\n    })];\n  }\n  if (!options.skipGenerated) {\n    if (hasRoutes && options.sitemap !== false) {\n      appendSitemapRoute(rootDirectory, options);\n    }\n    if (options.notFound !== false) {\n      appendNotFoundRoute(rootDirectory, options);\n    }\n  }\n  return rootDirectory;\n}\nfunction getNameFromRedirectPath(path) {\n  return (0, matchers_1.removeFileSystemExtensions)((0, matchers_1.removeFileSystemDots)(path)).replace(/^\\//, '');\n}\nfunction getNameWithoutInvisibleSegmentsFromRedirectPath(path) {\n  return (0, matchers_1.stripInvisibleSegmentsFromPath)(getNameFromRedirectPath(path));\n}\nfunction getSourceContextKeyFromRedirectSource(source) {\n  const name = getNameFromRedirectPath(source);\n  const prefix = './';\n  const suffix = /\\.[tj]sx?$/.test(name) ? '' : '.js';\n  return `${prefix}${name}${suffix}`;\n}\nfunction flattenDirectoryTreeToRoutes(directory, options, layout, pathToRemove = '') {\n  if (directory.layout) {\n    const previousLayout = layout;\n    layout = getMostSpecific(directory.layout);\n    if (previousLayout) {\n      previousLayout.children.push(layout);\n    }\n    if (options.internal_stripLoadRoute) {\n      delete layout.loadRoute;\n    }\n    const newRoute = layout.route.replace(pathToRemove, '');\n    pathToRemove = layout.route ? `${layout.route}/` : '';\n    layout.route = newRoute;\n    layout.dynamic = generateDynamic(layout.contextKey.slice(0));\n  }\n  if (!layout) throw new Error('Expo Router Internal Error: No nearest layout');\n  for (const routes of directory.files.values()) {\n    const routeNode = getMostSpecific(routes);\n    routeNode.route = routeNode.route.replace(pathToRemove, '');\n    routeNode.dynamic = generateDynamic(routeNode.route);\n    if (options.internal_stripLoadRoute) {\n      delete routeNode.loadRoute;\n    }\n    layout.children.push(routeNode);\n  }\n  for (const child of directory.subdirectories.values()) {\n    flattenDirectoryTreeToRoutes(child, options, layout, pathToRemove);\n  }\n  return layout;\n}\nfunction getFileMeta(originalKey, options, redirects, rewrites) {\n  const key = (0, matchers_1.removeSupportedExtensions)((0, matchers_1.removeFileSystemDots)(originalKey));\n  let route = key;\n  const parts = (0, matchers_1.removeFileSystemDots)(originalKey).split('/');\n  const filename = parts[parts.length - 1];\n  const [filenameWithoutExtensions, platformExtension] = (0, matchers_1.removeSupportedExtensions)(filename).split('.');\n  const isLayout = filenameWithoutExtensions === '_layout';\n  const isApi = originalKey.match(/\\+api\\.(\\w+\\.)?[jt]sx?$/);\n  if (filenameWithoutExtensions.startsWith('(') && filenameWithoutExtensions.endsWith(')')) {\n    throw new Error(`Invalid route ${originalKey}. Routes cannot end with '(group)' syntax`);\n  }\n  if (!isApi && filename.startsWith('+') && filenameWithoutExtensions !== '+not-found') {\n    const renamedRoute = [...parts.slice(0, -1), filename.slice(1)].join('/');\n    throw new Error(`Invalid route ${originalKey}. Route nodes cannot start with the '+' character. \"Rename it to ${renamedRoute}\"`);\n  }\n  let specificity = 0;\n  const hasPlatformExtension = validPlatforms.has(platformExtension);\n  const usePlatformRoutes = options.platformRoutes ?? true;\n  if (hasPlatformExtension) {\n    if (!usePlatformRoutes) {\n      specificity = -1;\n    } else if (!options.platform) {\n      specificity = -1;\n    } else if (platformExtension === options.platform) {\n      specificity = 2;\n    } else if (platformExtension === 'native' && options.platform !== 'web') {\n      specificity = 1;\n    } else if (platformExtension !== options.platform) {\n      specificity = -1;\n    }\n    if (isApi && specificity !== 0) {\n      throw new Error(`API routes cannot have platform extensions. Remove '.${platformExtension}' from '${originalKey}'`);\n    }\n    route = route.replace(new RegExp(`.${platformExtension}$`), '');\n  }\n  return {\n    route,\n    specificity,\n    isLayout,\n    isApi,\n    isRedirect: key in redirects,\n    isRewrite: key in rewrites\n  };\n}\nfunction extrapolateGroups(key, keys = new Set()) {\n  const match = (0, matchers_1.matchArrayGroupName)(key);\n  if (!match) {\n    keys.add(key);\n    return keys;\n  }\n  const groups = match.split(',');\n  const groupsSet = new Set(groups);\n  if (groupsSet.size !== groups.length) {\n    throw new Error(`Array syntax cannot contain duplicate group name \"${groups}\" in \"${key}\".`);\n  }\n  if (groups.length === 1) {\n    keys.add(key);\n    return keys;\n  }\n  for (const group of groups) {\n    extrapolateGroups(key.replace(match, group.trim()), keys);\n  }\n  return keys;\n}\nfunction generateDynamic(path) {\n  const dynamic = path.split('/').map(part => {\n    if (part === '+not-found') {\n      return {\n        name: '+not-found',\n        deep: true,\n        notFound: true\n      };\n    }\n    return (0, matchers_1.matchDynamicName)(part) ?? null;\n  }).filter(part => !!part);\n  return dynamic.length === 0 ? null : dynamic;\n}\nfunction appendSitemapRoute(directory, options) {\n  if (!directory.files.has('_sitemap') && options.getSystemRoute) {\n    directory.files.set('_sitemap', [options.getSystemRoute({\n      type: 'route',\n      route: '_sitemap'\n    })]);\n  }\n}\nfunction appendNotFoundRoute(directory, options) {\n  if (!directory.files.has('+not-found') && options.getSystemRoute) {\n    directory.files.set('+not-found', [options.getSystemRoute({\n      type: 'route',\n      route: '+not-found'\n    })]);\n  }\n}\nfunction getLayoutNode(node, options) {\n  const groupName = (0, matchers_1.matchLastGroupName)(node.route);\n  const childMatchingGroup = node.children.find(child => {\n    return child.route.replace(/\\/index$/, '') === groupName;\n  });\n  let anchor = childMatchingGroup?.route;\n  const loaded = node.loadRoute();\n  if (loaded?.unstable_settings) {\n    try {\n      anchor = loaded.unstable_settings.anchor ?? loaded.unstable_settings.initialRouteName ?? anchor;\n    } catch (error) {\n      if (error instanceof Error) {\n        if (!error.message.match(/You cannot dot into a client module/)) {\n          throw error;\n        }\n      }\n    }\n    if (groupName) {\n      const groupSpecificInitialRouteName = loaded.unstable_settings?.[groupName]?.anchor ?? loaded.unstable_settings?.[groupName]?.initialRouteName;\n      anchor = groupSpecificInitialRouteName ?? anchor;\n    }\n  }\n  return Object.assign({}, node, {\n    route: node.route.replace(/\\/?_layout$/, ''),\n    children: [],\n    initialRouteName: anchor\n  });\n}\nfunction crawlAndAppendInitialRoutesAndEntryFiles(node, options, entryPoints = []) {\n  if (node.type === 'route') {\n    node.entryPoints = [...new Set([...entryPoints, node.contextKey])];\n  } else if (node.type === 'redirect') {\n    node.entryPoints = [...new Set([...entryPoints, node.destinationContextKey])];\n  } else if (node.type === 'layout') {\n    if (!node.children) {\n      throw new Error(`Layout \"${node.contextKey}\" does not contain any child routes`);\n    }\n    entryPoints = [...entryPoints, node.contextKey];\n    const groupName = (0, matchers_1.matchGroupName)(node.route);\n    const childMatchingGroup = node.children.find(child => {\n      return child.route.replace(/\\/index$/, '') === groupName;\n    });\n    let anchor = childMatchingGroup?.route;\n    if (!options.internal_stripLoadRoute) {\n      const loaded = node.loadRoute();\n      if (loaded?.unstable_settings) {\n        try {\n          anchor = loaded.unstable_settings.anchor ?? loaded.unstable_settings.initialRouteName ?? anchor;\n        } catch (error) {\n          if (error instanceof Error) {\n            if (!error.message.match(/You cannot dot into a client module/)) {\n              throw error;\n            }\n          }\n        }\n        if (groupName) {\n          const groupSpecificInitialRouteName = loaded.unstable_settings?.[groupName]?.anchor ?? loaded.unstable_settings?.[groupName]?.initialRouteName;\n          anchor = groupSpecificInitialRouteName ?? anchor;\n        }\n      }\n    }\n    if (anchor) {\n      const anchorRoute = node.children.find(child => child.route === anchor);\n      if (!anchorRoute) {\n        const validAnchorRoutes = node.children.filter(child => !child.generated).map(child => `'${child.route}'`).join(', ');\n        if (groupName) {\n          throw new Error(`Layout ${node.contextKey} has invalid anchor '${anchor}' for group '(${groupName})'. Valid options are: ${validAnchorRoutes}`);\n        } else {\n          throw new Error(`Layout ${node.contextKey} has invalid anchor '${anchor}'. Valid options are: ${validAnchorRoutes}`);\n        }\n      }\n      node.initialRouteName = anchor;\n      entryPoints.push(anchorRoute.contextKey);\n    }\n    for (const child of node.children) {\n      crawlAndAppendInitialRoutesAndEntryFiles(child, options, entryPoints);\n    }\n  }\n}\nfunction getMostSpecific(routes) {\n  const route = routes[routes.length - 1];\n  if (!routes[0]) {\n    throw new Error(`The file ${route.contextKey} does not have a fallback sibling file without a platform extension.`);\n  }\n  return routes[routes.length - 1];\n}","map":{"version":3,"names":["exports","getRoutes","extrapolateGroups","generateDynamic","matchers_1","require","url_1","validPlatforms","Set","contextModule","options","middleware","getMiddleware","directoryTree","getDirectoryTree","rootNode","flattenDirectoryTreeToRoutes","ignoreEntryPoints","crawlAndAppendInitialRoutesAndEntryFiles","allMiddlewareFiles","keys","filter","key","includes","unstable_useServerMiddleware","length","console","warn","JSON","stringify","expo","plugins","isValidMiddleware","test","rootMiddlewareFiles","nonRootMiddleware","file","Error","join","process","env","NODE_ENV","map","p","middlewareFilePath","loadRoute","ignoreRequireErrors","contextKey","internal_stripLoadRoute","importMode","ignoreList","ignore","push","preserveApiRoutes","rootDirectory","files","Map","subdirectories","hasRoutes","isValid","contextKeys","redirects","rewrites","validRedirectDestinations","getValidDestinations","nameWithoutInvisible","getNameWithoutInvisibleSegmentsFromRedirectPath","removeSupportedExtensions","preserveRedirectAndRewrites","redirect","sourceContextKey","getSourceContextKeyFromRedirectSource","source","sourceName","getNameFromRedirectPath","isExternalRedirect","shouldLinkExternally","destination","targetDestinationName","some","regex","validDestination","undefined","find","destinationContextKey","permanent","Boolean","external","methods","rewrite","isSourceContextKeyAlreadyKnown","processedRedirectsRewrites","filePath","meta","getFileMeta","specificity","node","type","isApi","isLayout","routeModule","Promise","defaultExport","default","Function","constructor","name","route","dynamic","children","isRedirect","has","generated","getSystemRoute","defaults","redirectConfig","add","isRewrite","rewriteConfig","routeItem","subdirectoryParts","split","slice","directory","part","subDirectory","get","set","Object","assign","layout","existing","getLayoutNode","fileKey","nodes","skipGenerated","sitemap","appendSitemapRoute","notFound","appendNotFoundRoute","path","removeFileSystemExtensions","removeFileSystemDots","replace","stripInvisibleSegmentsFromPath","prefix","suffix","pathToRemove","previousLayout","getMostSpecific","newRoute","routes","values","routeNode","child","originalKey","parts","filename","filenameWithoutExtensions","platformExtension","match","startsWith","endsWith","renamedRoute","hasPlatformExtension","usePlatformRoutes","platformRoutes","platform","RegExp","matchArrayGroupName","groups","groupsSet","size","group","trim","deep","matchDynamicName","groupName","matchLastGroupName","childMatchingGroup","anchor","loaded","unstable_settings","initialRouteName","error","message","groupSpecificInitialRouteName","entryPoints","matchGroupName","anchorRoute","validAnchorRoutes"],"sources":["/Users/sbudhwar/workspace/github/tomanage/node_modules/expo-router/src/getRoutesCore.ts"],"sourcesContent":["import type { DynamicConvention, MiddlewareNode, RouteNode } from './Route';\nimport {\n  matchArrayGroupName,\n  matchDynamicName,\n  matchGroupName,\n  matchLastGroupName,\n  removeFileSystemDots,\n  removeFileSystemExtensions,\n  removeSupportedExtensions,\n  stripInvisibleSegmentsFromPath,\n} from './matchers';\nimport type { RequireContext } from './types';\nimport { shouldLinkExternally } from './utils/url';\n\nexport type Options = {\n  ignore?: RegExp[];\n  preserveApiRoutes?: boolean;\n  ignoreRequireErrors?: boolean;\n  ignoreEntryPoints?: boolean;\n  /* Used to simplify testing for toEqual() comparison */\n  internal_stripLoadRoute?: boolean;\n  /* Used to simplify by skipping the generated routes */\n  skipGenerated?: boolean;\n  /* Skip the generated not found route  */\n  notFound?: boolean;\n  /* Enable experimental server middleware support */\n  unstable_useServerMiddleware?: boolean;\n  importMode?: string;\n  platformRoutes?: boolean;\n  sitemap?: boolean;\n  platform?: string;\n  redirects?: RedirectConfig[];\n  rewrites?: RewriteConfig[];\n  headers?: Record<string, string | string[]>;\n  /* Keep redirects as valid routes within the RouteConfig tree */\n  preserveRedirectAndRewrites?: boolean;\n\n  /** Get the system route for a location. Useful for shimming React Native imports in SSR environments. */\n  getSystemRoute: (\n    route: Pick<RouteNode, 'route' | 'type'> & {\n      defaults?: RouteNode;\n      redirectConfig?: RedirectConfig;\n      rewriteConfig?: RewriteConfig;\n    }\n  ) => RouteNode;\n};\n\ntype DirectoryNode = {\n  layout?: RouteNode[];\n  files: Map<string, RouteNode[]>;\n  subdirectories: Map<string, DirectoryNode>;\n};\n\nexport type RedirectConfig = {\n  source: string;\n  destination: string;\n  destinationContextKey: string;\n  permanent?: boolean;\n  methods?: string[];\n  external?: boolean;\n};\n\nexport type RewriteConfig = {\n  source: string;\n  destination: string;\n  destinationContextKey: string;\n  methods?: string[];\n};\n\nconst validPlatforms = new Set(['android', 'ios', 'native', 'web']);\n\n/**\n * Given a Metro context module, return an array of nested routes.\n *\n * This is a two step process:\n *  1. Convert the RequireContext keys (file paths) into a directory tree.\n *      - This should extrapolate array syntax into multiple routes\n *      - Routes are given a specificity score\n *  2. Flatten the directory tree into routes\n *      - Routes in directories without _layout files are hoisted to the nearest _layout\n *      - The name of the route is relative to the nearest _layout\n *      - If multiple routes have the same name, the most specific route is used\n */\nexport function getRoutes(contextModule: RequireContext, options: Options): RouteNode | null {\n  const middleware = getMiddleware(contextModule, options);\n  const directoryTree = getDirectoryTree(contextModule, options);\n\n  // If there are no routes\n  if (!directoryTree) {\n    return null;\n  }\n\n  const rootNode = flattenDirectoryTreeToRoutes(directoryTree, options);\n\n  if (middleware) {\n    rootNode.middleware = middleware;\n  }\n\n  if (!options.ignoreEntryPoints) {\n    crawlAndAppendInitialRoutesAndEntryFiles(rootNode, options);\n  }\n\n  return rootNode;\n}\n\n/**\n * Given a RequireContext, return the middleware node if one is found. If more than one middleware file is found, an error is thrown.\n */\nfunction getMiddleware(contextModule: RequireContext, options: Options): MiddlewareNode | null {\n  const allMiddlewareFiles = contextModule.keys().filter((key) => key.includes('+middleware'));\n\n  // Check if middleware is enabled via plugin config\n  if (!options.unstable_useServerMiddleware) {\n    if (allMiddlewareFiles.length > 0) {\n      console.warn(\n        'Server middleware is not enabled. Add unstable_useServerMiddleware: true to your `expo-router` plugin config.\\n\\n' +\n          JSON.stringify(\n            {\n              expo: {\n                plugins: [['expo-router', { unstable_useServerMiddleware: true }]],\n              },\n            },\n            null,\n            2\n          )\n      );\n    }\n    return null;\n  }\n\n  const isValidMiddleware = (key: string) => /^\\.\\/\\+middleware\\.[tj]sx?$/.test(key);\n\n  const rootMiddlewareFiles = allMiddlewareFiles.filter(isValidMiddleware);\n\n  const nonRootMiddleware = allMiddlewareFiles.filter(\n    (file) => !rootMiddlewareFiles.includes(file)\n  );\n  if (nonRootMiddleware.length > 0) {\n    throw new Error(\n      `The middleware file can only be placed at the root level. Remove the following files: ${nonRootMiddleware.join(', ')}`\n    );\n  }\n\n  if (rootMiddlewareFiles.length === 0) {\n    return null;\n  }\n\n  // In development, throw an error if there are multiple root-level middleware files\n  if (rootMiddlewareFiles.length > 1) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Only one middleware file is allowed. Keep one of the conflicting files: ${rootMiddlewareFiles.map((p) => `\"${p}\"`).join(' or ')}`\n      );\n    }\n  }\n\n  const middlewareFilePath = rootMiddlewareFiles[0];\n\n  const middleware: MiddlewareNode = {\n    loadRoute() {\n      if (options.ignoreRequireErrors) {\n        try {\n          return contextModule(middlewareFilePath);\n        } catch {\n          return {};\n        }\n      } else {\n        return contextModule(middlewareFilePath);\n      }\n    },\n    contextKey: middlewareFilePath,\n  };\n\n  if (options.internal_stripLoadRoute) {\n    delete (middleware as any).loadRoute;\n  }\n\n  return middleware;\n}\n\n/**\n * Converts the RequireContext keys (file paths) into a directory tree.\n */\nfunction getDirectoryTree(contextModule: RequireContext, options: Options) {\n  const importMode = options.importMode || process.env.EXPO_ROUTER_IMPORT_MODE;\n\n  const ignoreList: RegExp[] = [/^\\.\\/\\+(html|native-intent)\\.[tj]sx?$/]; // Ignore the top level ./+html file\n\n  if (options.ignore) {\n    ignoreList.push(...options.ignore);\n  }\n  if (!options.preserveApiRoutes) {\n    ignoreList.push(/\\+api$/, /\\+api\\.[tj]sx?$/);\n  }\n\n  // Always ignore middleware files in regular route processing\n  ignoreList.push(/\\+middleware$/, /\\+middleware\\.[tj]sx?$/);\n\n  const rootDirectory: DirectoryNode = {\n    files: new Map(),\n    subdirectories: new Map(),\n  };\n\n  let hasRoutes = false;\n  let isValid = false;\n\n  const contextKeys = contextModule.keys();\n  const redirects: Record<string, RedirectConfig> = {};\n  const rewrites: Record<string, RewriteConfig> = {};\n\n  let validRedirectDestinations: { contextKey: string; nameWithoutInvisible: string }[] | undefined;\n\n  const getValidDestinations = () => {\n    // Loop over contexts once and cache the valid destinations\n    validRedirectDestinations ??= contextKeys.map((key) => {\n      return {\n        contextKey: key,\n        nameWithoutInvisible: getNameWithoutInvisibleSegmentsFromRedirectPath(\n          removeSupportedExtensions(key)\n        ),\n      };\n    });\n    return validRedirectDestinations;\n  };\n\n  // If we are keeping redirects as valid routes, then we need to add them to the contextKeys\n  // This is useful for generating a sitemap with redirects, or static site generation that includes redirects\n  if (options.preserveRedirectAndRewrites) {\n    if (options.redirects) {\n      for (const redirect of options.redirects) {\n        const sourceContextKey = getSourceContextKeyFromRedirectSource(redirect.source);\n        const sourceName = getNameFromRedirectPath(redirect.source);\n\n        const isExternalRedirect = shouldLinkExternally(redirect.destination);\n\n        const targetDestinationName = isExternalRedirect\n          ? redirect.destination\n          : getNameWithoutInvisibleSegmentsFromRedirectPath(redirect.destination);\n\n        if (ignoreList.some((regex) => regex.test(sourceContextKey))) {\n          continue;\n        }\n\n        const validDestination = isExternalRedirect\n          ? undefined\n          : getValidDestinations().find(\n              (key) => key.nameWithoutInvisible === targetDestinationName\n            );\n        const destination = isExternalRedirect\n          ? targetDestinationName\n          : validDestination?.nameWithoutInvisible;\n        const destinationContextKey = isExternalRedirect\n          ? targetDestinationName\n          : validDestination?.contextKey;\n\n        if (!destinationContextKey || destination === undefined) {\n          /*\n           * Only throw the error when we are preserving the api routes\n           * When doing a static export, API routes will not exist so the redirect destination may not exist.\n           * The desired behavior for this error is to warn the user when running `expo start`, so its ok if\n           * `expo export` swallows this error.\n           */\n          if (options.preserveApiRoutes) {\n            throw new Error(`Redirect destination \"${redirect.destination}\" does not exist.`);\n          }\n\n          continue;\n        }\n\n        contextKeys.push(sourceContextKey);\n        redirects[sourceName] = {\n          source: sourceName,\n          destination,\n          destinationContextKey,\n          permanent: Boolean(redirect.permanent),\n          external: isExternalRedirect,\n          methods: redirect.methods,\n        };\n      }\n    }\n\n    if (options.rewrites) {\n      for (const rewrite of options.rewrites) {\n        const sourceContextKey = getSourceContextKeyFromRedirectSource(rewrite.source);\n        const sourceName = getNameFromRedirectPath(rewrite.source);\n\n        // We check to see if the context key is already known so that we don't create a rewrite for\n        // a route that already exists on disk\n        const isSourceContextKeyAlreadyKnown = contextKeys.includes(sourceContextKey);\n        const targetDestinationName = isSourceContextKeyAlreadyKnown\n          ? getNameFromRedirectPath(rewrite.destination)\n          : getNameWithoutInvisibleSegmentsFromRedirectPath(rewrite.destination);\n\n        if (ignoreList.some((regex) => regex.test(sourceContextKey))) {\n          continue;\n        }\n\n        const validDestination = getValidDestinations().find(\n          (key) => key.nameWithoutInvisible === targetDestinationName\n        );\n        const destination = validDestination?.nameWithoutInvisible;\n        const destinationContextKey = validDestination?.contextKey;\n\n        if (!destinationContextKey || destination === undefined) {\n          /*\n           * Only throw the error when we are preserving the api routes\n           * When doing a static export, API routes will not exist so the redirect destination may not exist.\n           * The desired behavior for this error is to warn the user when running `expo start`, so its ok if\n           * `expo export` swallows this error.\n           */\n          if (options.preserveApiRoutes) {\n            throw new Error(`Rewrite destination \"${rewrite.destination}\" does not exist.`);\n          }\n\n          continue;\n        }\n\n        contextKeys.push(sourceContextKey);\n        rewrites[sourceName] = {\n          source: sourceName,\n          destination,\n          destinationContextKey,\n          methods: rewrite.methods,\n        };\n      }\n    }\n  }\n\n  const processedRedirectsRewrites = new Set<string>();\n\n  for (const filePath of contextKeys) {\n    if (ignoreList.some((regex) => regex.test(filePath))) {\n      continue;\n    }\n\n    isValid = true;\n\n    const meta = getFileMeta(filePath, options, redirects, rewrites);\n\n    // This is a file that should be ignored. e.g maybe it has an invalid platform?\n    if (meta.specificity < 0) {\n      continue;\n    }\n\n    let node: RouteNode = {\n      type: meta.isApi ? 'api' : meta.isLayout ? 'layout' : 'route',\n      loadRoute() {\n        let routeModule: any;\n\n        if (options.ignoreRequireErrors) {\n          try {\n            routeModule = contextModule(filePath);\n          } catch {\n            routeModule = {};\n          }\n        } else {\n          routeModule = contextModule(filePath);\n        }\n\n        if (process.env.NODE_ENV === 'development' && importMode === 'sync') {\n          // In development mode, when async routes are disabled, add some extra error handling to improve the developer experience.\n          // This can be useful when you accidentally use an async function in a route file for the default export.\n          if (routeModule instanceof Promise) {\n            throw new Error(\n              `Route \"${filePath}\" cannot be a promise when async routes is disabled.`\n            );\n          }\n\n          const defaultExport = routeModule?.default;\n          if (defaultExport instanceof Promise) {\n            throw new Error(\n              `The default export from route \"${filePath}\" is a promise. Ensure the React Component does not use async or promises.`\n            );\n          }\n\n          // check if default is an async function without invoking it\n          if (\n            defaultExport instanceof Function &&\n            // This only works on web because Hermes support async functions so we have to transform them out.\n            defaultExport.constructor.name === 'AsyncFunction'\n          ) {\n            throw new Error(\n              `The default export from route \"${filePath}\" is an async function. Ensure the React Component does not use async or promises.`\n            );\n          }\n        }\n\n        return routeModule;\n      },\n      contextKey: filePath,\n      route: '', // This is overwritten during hoisting based upon the _layout\n      dynamic: null,\n      children: [], // While we are building the directory tree, we don't know the node's children just yet. This is added during hoisting\n    };\n\n    if (meta.isRedirect) {\n      if (processedRedirectsRewrites.has(meta.route)) {\n        continue;\n      }\n\n      const redirect = redirects[meta.route];\n      node.destinationContextKey = redirect.destinationContextKey;\n      node.permanent = redirect.permanent;\n      node.generated = true;\n      if (node.type === 'route') {\n        node = options.getSystemRoute({\n          type: 'redirect',\n          route: redirect.destination,\n          defaults: node,\n          redirectConfig: redirect,\n        });\n      }\n      if (redirect.methods) {\n        node.methods = redirect.methods;\n      }\n      node.type = 'redirect';\n      processedRedirectsRewrites.add(meta.route);\n    }\n\n    if (meta.isRewrite) {\n      if (processedRedirectsRewrites.has(meta.route)) {\n        continue;\n      }\n\n      const rewrite = rewrites[meta.route];\n      node.destinationContextKey = rewrite.destinationContextKey;\n      node.generated = true;\n      if (node.type === 'route') {\n        node = options.getSystemRoute({\n          type: 'rewrite',\n          route: rewrite.destination,\n          defaults: node,\n          rewriteConfig: rewrite,\n        });\n      }\n      if (rewrite.methods) {\n        node.methods = rewrite.methods;\n      }\n      node.type = 'rewrite';\n      processedRedirectsRewrites.add(meta.route);\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      // If the user has set the `EXPO_ROUTER_IMPORT_MODE` to `sync` then we should\n      // filter the missing routes.\n      if (node.type !== 'api' && importMode === 'sync') {\n        const routeItem = node.loadRoute();\n        // Have a warning for nullish ex\n        const route = routeItem?.default;\n        if (route == null) {\n          // Do not throw an error since a user may just be creating a new route.\n          console.warn(\n            `Route \"${filePath}\" is missing the required default export. Ensure a React component is exported as default.`\n          );\n          continue;\n        }\n        if (['boolean', 'number', 'string'].includes(typeof route)) {\n          throw new Error(\n            `The default export from route \"${filePath}\" is an unsupported type: \"${typeof route}\". Only React Components are supported as default exports from route files.`\n          );\n        }\n      }\n    }\n\n    /**\n     * A single filepath may be extrapolated into multiple routes if it contains array syntax.\n     * Another way to thinking about is that a filepath node is present in multiple leaves of the directory tree.\n     */\n    for (const route of extrapolateGroups(meta.route)) {\n      // Traverse the directory tree to its leaf node, creating any missing directories along the way\n      const subdirectoryParts = route.split('/').slice(0, -1);\n\n      // Start at the root directory and traverse the path to the leaf directory\n      let directory = rootDirectory;\n\n      for (const part of subdirectoryParts) {\n        let subDirectory = directory.subdirectories.get(part);\n\n        // Create any missing subdirectories\n        if (!subDirectory) {\n          subDirectory = {\n            files: new Map(),\n            subdirectories: new Map(),\n          };\n          directory.subdirectories.set(part, subDirectory);\n        }\n\n        directory = subDirectory;\n      }\n\n      // Clone the node for this route\n      node = { ...node, route };\n\n      if (meta.isLayout) {\n        directory.layout ??= [];\n        const existing = directory.layout[meta.specificity];\n        if (existing) {\n          // In production, use the first route found\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\n              `The layouts \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Remove or rename one of these files.`\n            );\n          }\n        } else {\n          node = getLayoutNode(node, options);\n          directory.layout[meta.specificity] = node;\n        }\n      } else if (meta.isApi) {\n        const fileKey = `${route}+api`;\n        let nodes = directory.files.get(fileKey);\n\n        if (!nodes) {\n          nodes = [];\n          directory.files.set(fileKey, nodes);\n        }\n\n        // API Routes have no specificity, they are always the first node\n        const existing = nodes[0];\n\n        if (existing) {\n          // In production, use the first route found\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\n              `The API route file \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Remove or rename one of these files.`\n            );\n          }\n        } else {\n          nodes[0] = node;\n        }\n      } else {\n        let nodes = directory.files.get(route);\n\n        if (!nodes) {\n          nodes = [];\n          directory.files.set(route, nodes);\n        }\n\n        /**\n         * If there is an existing node with the same specificity, then we have a conflict.\n         * NOTE(Platform Routes):\n         *    We cannot check for specificity conflicts here, as we haven't processed all the context keys yet!\n         *    This will be checked during hoisting, as well as enforcing that all routes have a non-platform route.\n         */\n        const existing = nodes[meta.specificity];\n        if (existing) {\n          // In production, use the first route found\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\n              `The route files \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Remove or rename one of these files.`\n            );\n          }\n        } else {\n          hasRoutes ||= true;\n          nodes[meta.specificity] = node;\n        }\n      }\n    }\n  }\n\n  // If there are no routes/layouts then we should display the tutorial.\n  if (!isValid) {\n    return null;\n  }\n\n  /**\n   * If there are no top-level _layout, add a default _layout\n   * While this is a generated route, it will still be generated even if skipGenerated is true.\n   */\n  if (!rootDirectory.layout) {\n    rootDirectory.layout = [\n      options.getSystemRoute({\n        type: 'layout',\n        route: '',\n      }),\n    ];\n  }\n\n  // Only include the sitemap if there are routes.\n  if (!options.skipGenerated) {\n    if (hasRoutes && options.sitemap !== false) {\n      appendSitemapRoute(rootDirectory, options);\n    }\n    if (options.notFound !== false) {\n      appendNotFoundRoute(rootDirectory, options);\n    }\n  }\n  return rootDirectory;\n}\n\nfunction getNameFromRedirectPath(path: string): string {\n  // Removing only the filesystem extensions, to be able to handle +api, +html\n  return (\n    removeFileSystemExtensions(removeFileSystemDots(path))\n      // Remove the leading `/`\n      .replace(/^\\//, '')\n  );\n}\n\nfunction getNameWithoutInvisibleSegmentsFromRedirectPath(path: string): string {\n  return stripInvisibleSegmentsFromPath(getNameFromRedirectPath(path));\n}\n\n// Creates fake context key for redirects and rewrites\nfunction getSourceContextKeyFromRedirectSource(source: string): string {\n  const name = getNameFromRedirectPath(source);\n  const prefix = './';\n  const suffix = /\\.[tj]sx?$/.test(name) ? '' : '.js'; // Ensure it has a file extension\n  return `${prefix}${name}${suffix}`;\n}\n\n/**\n * Flatten the directory tree into routes, hoisting routes to the nearest _layout.\n */\nfunction flattenDirectoryTreeToRoutes(\n  directory: DirectoryNode,\n  options: Options,\n  /* The nearest _layout file in the directory tree */\n  layout?: RouteNode,\n  /* Route names are relative to their layout */\n  pathToRemove = ''\n) {\n  /**\n   * This directory has a _layout file so it becomes the new target for hoisting routes.\n   */\n  if (directory.layout) {\n    const previousLayout = layout;\n    layout = getMostSpecific(directory.layout);\n\n    // Add the new layout as a child of its parent\n    if (previousLayout) {\n      previousLayout.children.push(layout);\n    }\n\n    if (options.internal_stripLoadRoute) {\n      delete (layout as any).loadRoute;\n    }\n\n    // `route` is the absolute pathname. We need to make this relative to the last _layout\n    const newRoute = layout.route.replace(pathToRemove, '');\n    pathToRemove = layout.route ? `${layout.route}/` : '';\n\n    // Now update this layout with the new relative route and dynamic conventions\n    layout.route = newRoute;\n    layout.dynamic = generateDynamic(layout.contextKey.slice(0));\n  }\n\n  // This should never occur as there will always be a root layout, but it makes the type system happy\n  if (!layout) throw new Error('Expo Router Internal Error: No nearest layout');\n\n  for (const routes of directory.files.values()) {\n    const routeNode = getMostSpecific(routes);\n\n    // `route` is the absolute pathname. We need to make this relative to the nearest layout\n    routeNode.route = routeNode.route.replace(pathToRemove, '');\n    routeNode.dynamic = generateDynamic(routeNode.route);\n\n    if (options.internal_stripLoadRoute) {\n      delete (routeNode as any).loadRoute;\n    }\n\n    layout.children.push(routeNode);\n  }\n\n  // Recursively flatten the subdirectories\n  for (const child of directory.subdirectories.values()) {\n    flattenDirectoryTreeToRoutes(child, options, layout, pathToRemove);\n  }\n\n  return layout;\n}\n\nfunction getFileMeta(\n  originalKey: string,\n  options: Options,\n  redirects: Record<string, RedirectConfig>,\n  rewrites: Record<string, RewriteConfig>\n) {\n  // Remove the leading `./`\n  const key = removeSupportedExtensions(removeFileSystemDots(originalKey));\n  let route = key;\n\n  const parts = removeFileSystemDots(originalKey).split('/');\n  const filename = parts[parts.length - 1];\n  const [filenameWithoutExtensions, platformExtension] =\n    removeSupportedExtensions(filename).split('.');\n\n  const isLayout = filenameWithoutExtensions === '_layout';\n  const isApi = originalKey.match(/\\+api\\.(\\w+\\.)?[jt]sx?$/);\n\n  if (filenameWithoutExtensions.startsWith('(') && filenameWithoutExtensions.endsWith(')')) {\n    throw new Error(`Invalid route ${originalKey}. Routes cannot end with '(group)' syntax`);\n  }\n\n  // Nested routes cannot start with the '+' character, except for the '+not-found' route\n  if (!isApi && filename.startsWith('+') && filenameWithoutExtensions !== '+not-found') {\n    const renamedRoute = [...parts.slice(0, -1), filename.slice(1)].join('/');\n    throw new Error(\n      `Invalid route ${originalKey}. Route nodes cannot start with the '+' character. \"Rename it to ${renamedRoute}\"`\n    );\n  }\n  let specificity = 0;\n\n  const hasPlatformExtension = validPlatforms.has(platformExtension);\n  const usePlatformRoutes = options.platformRoutes ?? true;\n\n  if (hasPlatformExtension) {\n    if (!usePlatformRoutes) {\n      // If the user has disabled platform routes, then we should ignore this file\n      specificity = -1;\n    } else if (!options.platform) {\n      // If we don't have a platform, then we should ignore this file\n      // This used by typed routes, sitemap, etc\n      specificity = -1;\n    } else if (platformExtension === options.platform) {\n      // If the platform extension is the same as the options.platform, then it is the most specific\n      specificity = 2;\n    } else if (platformExtension === 'native' && options.platform !== 'web') {\n      // `native` is allow but isn't as specific as the platform\n      specificity = 1;\n    } else if (platformExtension !== options.platform) {\n      // Somehow we have a platform extension that doesn't match the options.platform and it isn't native\n      // This is an invalid file and we will ignore it\n      specificity = -1;\n    }\n\n    if (isApi && specificity !== 0) {\n      throw new Error(\n        `API routes cannot have platform extensions. Remove '.${platformExtension}' from '${originalKey}'`\n      );\n    }\n\n    route = route.replace(new RegExp(`.${platformExtension}$`), '');\n  }\n\n  return {\n    route,\n    specificity,\n    isLayout,\n    isApi,\n    isRedirect: key in redirects,\n    isRewrite: key in rewrites,\n  };\n}\n\n/**\n * Generates a set of strings which have the router array syntax extrapolated.\n *\n * /(a,b)/(c,d)/e.tsx => new Set(['a/c/e.tsx', 'a/d/e.tsx', 'b/c/e.tsx', 'b/d/e.tsx'])\n */\nexport function extrapolateGroups(key: string, keys: Set<string> = new Set()): Set<string> {\n  const match = matchArrayGroupName(key);\n\n  if (!match) {\n    keys.add(key);\n    return keys;\n  }\n  const groups = match.split(',');\n  const groupsSet = new Set(groups);\n\n  if (groupsSet.size !== groups.length) {\n    throw new Error(`Array syntax cannot contain duplicate group name \"${groups}\" in \"${key}\".`);\n  }\n\n  if (groups.length === 1) {\n    keys.add(key);\n    return keys;\n  }\n\n  for (const group of groups) {\n    extrapolateGroups(key.replace(match, group.trim()), keys);\n  }\n\n  return keys;\n}\n\nexport function generateDynamic(path: string): DynamicConvention[] | null {\n  const dynamic = path\n    .split('/')\n    .map((part): DynamicConvention | null => {\n      if (part === '+not-found') {\n        return {\n          name: '+not-found',\n          deep: true,\n          notFound: true,\n        };\n      }\n      return matchDynamicName(part) ?? null;\n    })\n    .filter((part): part is DynamicConvention => !!part);\n\n  return dynamic.length === 0 ? null : dynamic;\n}\n\nfunction appendSitemapRoute(directory: DirectoryNode, options: Options) {\n  if (!directory.files.has('_sitemap') && options.getSystemRoute) {\n    directory.files.set('_sitemap', [\n      options.getSystemRoute({\n        type: 'route',\n        route: '_sitemap',\n      }),\n    ]);\n  }\n}\n\nfunction appendNotFoundRoute(directory: DirectoryNode, options: Options) {\n  if (!directory.files.has('+not-found') && options.getSystemRoute) {\n    directory.files.set('+not-found', [\n      options.getSystemRoute({\n        type: 'route',\n        route: '+not-found',\n      }),\n    ]);\n  }\n}\n\nfunction getLayoutNode(node: RouteNode, options: Options) {\n  /**\n   * A file called `(a,b)/(c)/_layout.tsx` will generate two _layout routes: `(a)/(c)/_layout` and `(b)/(c)/_layout`.\n   * Each of these layouts will have a different anchor based upon the first group name.\n   */\n  // We may strip loadRoute during testing\n  const groupName = matchLastGroupName(node.route);\n  const childMatchingGroup = node.children.find((child) => {\n    return child.route.replace(/\\/index$/, '') === groupName;\n  });\n  let anchor = childMatchingGroup?.route;\n  const loaded = node.loadRoute();\n  if (loaded?.unstable_settings) {\n    try {\n      // Allow unstable_settings={ initialRouteName: '...' } to override the default initial route name.\n      anchor =\n        loaded.unstable_settings.anchor ?? loaded.unstable_settings.initialRouteName ?? anchor;\n    } catch (error: any) {\n      if (error instanceof Error) {\n        if (!error.message.match(/You cannot dot into a client module/)) {\n          throw error;\n        }\n      }\n    }\n\n    if (groupName) {\n      // Allow unstable_settings={ 'custom': { initialRouteName: '...' } } to override the less specific initial route name.\n      const groupSpecificInitialRouteName =\n        loaded.unstable_settings?.[groupName]?.anchor ??\n        loaded.unstable_settings?.[groupName]?.initialRouteName;\n\n      anchor = groupSpecificInitialRouteName ?? anchor;\n    }\n  }\n\n  return {\n    ...node,\n    route: node.route.replace(/\\/?_layout$/, ''),\n    children: [], // Each layout should have its own children\n    initialRouteName: anchor,\n  };\n}\n\nfunction crawlAndAppendInitialRoutesAndEntryFiles(\n  node: RouteNode,\n  options: Options,\n  entryPoints: string[] = []\n) {\n  if (node.type === 'route') {\n    node.entryPoints = [...new Set([...entryPoints, node.contextKey])];\n  } else if (node.type === 'redirect') {\n    node.entryPoints = [...new Set([...entryPoints, node.destinationContextKey!])];\n  } else if (node.type === 'layout') {\n    if (!node.children) {\n      throw new Error(`Layout \"${node.contextKey}\" does not contain any child routes`);\n    }\n\n    // Every node below this layout will have it as an entryPoint\n    entryPoints = [...entryPoints, node.contextKey];\n\n    /**\n     * Calculate the initialRouteNode\n     *\n     * A file called `(a,b)/(c)/_layout.tsx` will generate two _layout routes: `(a)/(c)/_layout` and `(b)/(c)/_layout`.\n     * Each of these layouts will have a different anchor based upon the first group.\n     */\n    const groupName = matchGroupName(node.route);\n    const childMatchingGroup = node.children.find((child) => {\n      return child.route.replace(/\\/index$/, '') === groupName;\n    });\n    let anchor = childMatchingGroup?.route;\n    // We may strip loadRoute during testing\n    if (!options.internal_stripLoadRoute) {\n      const loaded = node.loadRoute();\n      if (loaded?.unstable_settings) {\n        try {\n          // Allow unstable_settings={ initialRouteName: '...' } to override the default initial route name.\n          anchor =\n            loaded.unstable_settings.anchor ?? loaded.unstable_settings.initialRouteName ?? anchor;\n        } catch (error: any) {\n          if (error instanceof Error) {\n            if (!error.message.match(/You cannot dot into a client module/)) {\n              throw error;\n            }\n          }\n        }\n\n        if (groupName) {\n          // Allow unstable_settings={ 'custom': { initialRouteName: '...' } } to override the less specific initial route name.\n          const groupSpecificInitialRouteName =\n            loaded.unstable_settings?.[groupName]?.anchor ??\n            loaded.unstable_settings?.[groupName]?.initialRouteName;\n\n          anchor = groupSpecificInitialRouteName ?? anchor;\n        }\n      }\n    }\n\n    if (anchor) {\n      const anchorRoute = node.children.find((child) => child.route === anchor);\n      if (!anchorRoute) {\n        const validAnchorRoutes = node.children\n          .filter((child) => !child.generated)\n          .map((child) => `'${child.route}'`)\n          .join(', ');\n\n        if (groupName) {\n          throw new Error(\n            `Layout ${node.contextKey} has invalid anchor '${anchor}' for group '(${groupName})'. Valid options are: ${validAnchorRoutes}`\n          );\n        } else {\n          throw new Error(\n            `Layout ${node.contextKey} has invalid anchor '${anchor}'. Valid options are: ${validAnchorRoutes}`\n          );\n        }\n      }\n\n      // Navigators can add initialsRoutes into the history, so they need to be to be included in the entryPoints\n      node.initialRouteName = anchor;\n      entryPoints.push(anchorRoute.contextKey);\n    }\n\n    for (const child of node.children) {\n      crawlAndAppendInitialRoutesAndEntryFiles(child, options, entryPoints);\n    }\n  }\n}\n\nfunction getMostSpecific(routes: RouteNode[]) {\n  const route = routes[routes.length - 1];\n\n  if (!routes[0]) {\n    throw new Error(\n      `The file ${route.contextKey} does not have a fallback sibling file without a platform extension.`\n    );\n  }\n\n  // This works even tho routes is holey array (e.g it might have index 0 and 2 but not 1)\n  // `.length` includes the holes in its count\n  return routes[routes.length - 1];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}