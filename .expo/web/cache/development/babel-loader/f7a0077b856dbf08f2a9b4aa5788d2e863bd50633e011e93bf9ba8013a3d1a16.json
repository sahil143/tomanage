{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function () {\n  var ownKeys = function (o) {\n    ownKeys = Object.getOwnPropertyNames || function (o) {\n      var ar = [];\n      for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n      return ar;\n    };\n    return ownKeys(o);\n  };\n  return function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n    __setModuleDefault(result, mod);\n    return result;\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.routingQueue = void 0;\nexports.navigate = navigate;\nexports.reload = reload;\nexports.prefetch = prefetch;\nexports.push = push;\nexports.dismiss = dismiss;\nexports.dismissTo = dismissTo;\nexports.replace = replace;\nexports.dismissAll = dismissAll;\nexports.goBack = goBack;\nexports.canGoBack = canGoBack;\nexports.canDismiss = canDismiss;\nexports.setParams = setParams;\nexports.linkTo = linkTo;\nexports.getPayloadFromStateRoute = getPayloadFromStateRoute;\nexports.findDivergentState = findDivergentState;\nconst dom_1 = require(\"expo/dom\");\nconst Linking = __importStar(require(\"expo-linking\"));\nconst react_native_1 = require(\"react-native-web/dist/index\");\nconst router_store_1 = require(\"./router-store\");\nconst emitDomEvent_1 = require(\"../domComponents/emitDomEvent\");\nconst getRoutesRedirects_1 = require(\"../getRoutesRedirects\");\nconst href_1 = require(\"../link/href\");\nconst matchers_1 = require(\"../matchers\");\nconst navigationParams_1 = require(\"../navigationParams\");\nconst url_1 = require(\"../utils/url\");\nfunction assertIsReady() {\n  if (!router_store_1.store.navigationRef.isReady()) {\n    throw new Error('Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.');\n  }\n}\nexports.routingQueue = {\n  queue: [],\n  subscribers: new Set(),\n  subscribe(callback) {\n    exports.routingQueue.subscribers.add(callback);\n    return () => {\n      exports.routingQueue.subscribers.delete(callback);\n    };\n  },\n  snapshot() {\n    return exports.routingQueue.queue;\n  },\n  add(action) {\n    exports.routingQueue.queue.push(action);\n    for (const callback of exports.routingQueue.subscribers) {\n      callback();\n    }\n  },\n  run(ref) {\n    const events = exports.routingQueue.queue;\n    exports.routingQueue.queue = [];\n    let action;\n    while (action = events.shift()) {\n      if (ref.current) {\n        ref.current.dispatch(action);\n      }\n    }\n  }\n};\nfunction navigate(url, options) {\n  return linkTo((0, href_1.resolveHref)(url), Object.assign({}, options, {\n    event: 'NAVIGATE'\n  }));\n}\nfunction reload() {\n  throw new Error('The reload method is not implemented in the client-side router yet.');\n}\nfunction prefetch(href, options) {\n  return linkTo((0, href_1.resolveHref)(href), Object.assign({}, options, {\n    event: 'PRELOAD'\n  }));\n}\nfunction push(url, options) {\n  return linkTo((0, href_1.resolveHref)(url), Object.assign({}, options, {\n    event: 'PUSH'\n  }));\n}\nfunction dismiss(count = 1) {\n  if ((0, emitDomEvent_1.emitDomDismiss)(count)) {\n    return;\n  }\n  exports.routingQueue.add({\n    type: 'POP',\n    payload: {\n      count\n    }\n  });\n}\nfunction dismissTo(href, options) {\n  return linkTo((0, href_1.resolveHref)(href), Object.assign({}, options, {\n    event: 'POP_TO'\n  }));\n}\nfunction replace(url, options) {\n  return linkTo((0, href_1.resolveHref)(url), Object.assign({}, options, {\n    event: 'REPLACE'\n  }));\n}\nfunction dismissAll() {\n  if ((0, emitDomEvent_1.emitDomDismissAll)()) {\n    return;\n  }\n  exports.routingQueue.add({\n    type: 'POP_TO_TOP'\n  });\n}\nfunction goBack() {\n  if ((0, emitDomEvent_1.emitDomGoBack)()) {\n    return;\n  }\n  assertIsReady();\n  exports.routingQueue.add({\n    type: 'GO_BACK'\n  });\n}\nfunction canGoBack() {\n  if (dom_1.IS_DOM) {\n    throw new Error('canGoBack imperative method is not supported. Pass the property to the DOM component instead.');\n  }\n  if (!router_store_1.store.navigationRef.isReady()) {\n    return false;\n  }\n  return router_store_1.store.navigationRef?.current?.canGoBack() ?? false;\n}\nfunction canDismiss() {\n  if (dom_1.IS_DOM) {\n    throw new Error('canDismiss imperative method is not supported. Pass the property to the DOM component instead.');\n  }\n  let state = router_store_1.store.state;\n  while (state) {\n    if (state.type === 'stack' && state.routes.length > 1) {\n      return true;\n    }\n    if (state.index === undefined) return false;\n    state = state.routes?.[state.index]?.state;\n  }\n  return false;\n}\nfunction setParams(params = {}) {\n  if ((0, emitDomEvent_1.emitDomSetParams)(params)) {\n    return;\n  }\n  assertIsReady();\n  return (router_store_1.store.navigationRef?.current?.setParams)(params);\n}\nfunction linkTo(originalHref, options = {}) {\n  originalHref = typeof originalHref == 'string' ? originalHref : (0, href_1.resolveHref)(originalHref);\n  let href = originalHref;\n  if ((0, emitDomEvent_1.emitDomLinkEvent)(href, options)) {\n    return;\n  }\n  if ((0, url_1.shouldLinkExternally)(href)) {\n    if (href.startsWith('//') && react_native_1.Platform.OS !== 'web') {\n      href = `https:${href}`;\n    }\n    Linking.openURL(href);\n    return;\n  }\n  assertIsReady();\n  const navigationRef = router_store_1.store.navigationRef.current;\n  if (navigationRef == null) {\n    throw new Error(\"Couldn't find a navigation object. Is your component inside NavigationContainer?\");\n  }\n  if (!router_store_1.store.linking) {\n    throw new Error('Attempted to link to route when no routes are present');\n  }\n  if (href === '..' || href === '../') {\n    navigationRef.goBack();\n    return;\n  }\n  const rootState = navigationRef.getRootState();\n  href = (0, href_1.resolveHrefStringWithSegments)(href, router_store_1.store.getRouteInfo(), options);\n  href = (0, getRoutesRedirects_1.applyRedirects)(href, router_store_1.store.redirects);\n  if (!href) {\n    return;\n  }\n  const state = router_store_1.store.linking.getStateFromPath(href, router_store_1.store.linking.config);\n  if (!state || state.routes.length === 0) {\n    console.error('Could not generate a valid navigation state for the given path: ' + href);\n    return;\n  }\n  exports.routingQueue.add(getNavigateAction(state, rootState, options.event, options.withAnchor, options.dangerouslySingular, !!options.__internal__PreviewKey));\n}\nfunction getNavigateAction(_actionState, _navigationState, type = 'NAVIGATE', withAnchor, singular, isPreviewNavigation) {\n  const {\n    actionStateRoute,\n    navigationState\n  } = findDivergentState(_actionState, _navigationState, type === 'PRELOAD');\n  const rootPayload = getPayloadFromStateRoute(actionStateRoute || {});\n  if (type === 'PUSH' && navigationState.type !== 'stack') {\n    type = 'NAVIGATE';\n  } else if (navigationState.type === 'expo-tab') {\n    type = 'JUMP_TO';\n  } else if (type === 'REPLACE' && navigationState.type === 'drawer') {\n    type = 'JUMP_TO';\n  }\n  if (withAnchor !== undefined) {\n    if (rootPayload.params.initial) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(`The parameter 'initial' is a reserved parameter name in React Navigation`);\n      }\n    }\n    rootPayload.params.initial = !withAnchor;\n  }\n  const expoParams = isPreviewNavigation ? {\n    __internal__expo_router_is_preview_navigation: true,\n    __internal_expo_router_no_animation: true\n  } : {};\n  const params = (0, navigationParams_1.appendInternalExpoRouterParams)(rootPayload.params, expoParams);\n  return {\n    type,\n    target: navigationState.key,\n    payload: {\n      name: rootPayload.screen,\n      params,\n      singular\n    }\n  };\n}\nfunction getPayloadFromStateRoute(_actionStateRoute) {\n  const rootPayload = {\n    params: {}\n  };\n  let payload = rootPayload;\n  let params = payload.params;\n  let actionStateRoute = _actionStateRoute;\n  while (actionStateRoute) {\n    Object.assign(params, Object.assign({}, payload.params, actionStateRoute.params));\n    payload.screen = actionStateRoute.name;\n    payload.params = Object.assign({}, params);\n    delete payload.params['screen'];\n    payload = payload.params;\n    params = payload;\n    actionStateRoute = actionStateRoute.state?.routes[actionStateRoute.state?.routes.length - 1];\n  }\n  return rootPayload;\n}\nfunction findDivergentState(_actionState, _navigationState, lookThroughAllTabs = false) {\n  let actionState = _actionState;\n  let navigationState = _navigationState;\n  let actionStateRoute;\n  const navigationRoutes = [];\n  while (actionState && navigationState) {\n    actionStateRoute = actionState.routes[actionState.routes.length - 1];\n    const stateRoute = (() => {\n      if (navigationState.type === 'tab' && lookThroughAllTabs) {\n        return navigationState.routes.find(route => route.name === actionStateRoute?.name) || navigationState.routes[navigationState.index ?? 0];\n      }\n      return navigationState.routes[navigationState.index ?? 0];\n    })();\n    const childState = actionStateRoute.state;\n    const nextNavigationState = stateRoute.state;\n    const dynamicName = (0, matchers_1.matchDynamicName)(actionStateRoute.name);\n    const didActionAndCurrentStateDiverge = actionStateRoute.name !== stateRoute.name || !childState || !nextNavigationState || dynamicName && actionStateRoute.params?.[dynamicName.name] !== stateRoute.params?.[dynamicName.name];\n    if (didActionAndCurrentStateDiverge) {\n      if (navigationState.type === 'tab' && lookThroughAllTabs) {\n        navigationRoutes.push(stateRoute);\n      }\n      break;\n    }\n    navigationRoutes.push(stateRoute);\n    actionState = childState;\n    navigationState = nextNavigationState;\n  }\n  return {\n    actionState,\n    navigationState,\n    actionStateRoute,\n    navigationRoutes\n  };\n}","map":{"version":3,"names":["exports","navigate","reload","prefetch","push","dismiss","dismissTo","replace","dismissAll","goBack","canGoBack","canDismiss","setParams","linkTo","getPayloadFromStateRoute","findDivergentState","dom_1","require","Linking","__importStar","react_native_1","router_store_1","emitDomEvent_1","getRoutesRedirects_1","href_1","matchers_1","navigationParams_1","url_1","assertIsReady","store","navigationRef","isReady","Error","routingQueue","queue","subscribers","Set","subscribe","callback","add","delete","snapshot","action","run","ref","events","shift","current","dispatch","url","options","resolveHref","Object","assign","event","href","count","emitDomDismiss","type","payload","emitDomDismissAll","emitDomGoBack","IS_DOM","state","routes","length","index","undefined","params","emitDomSetParams","originalHref","emitDomLinkEvent","shouldLinkExternally","startsWith","Platform","OS","openURL","linking","rootState","getRootState","resolveHrefStringWithSegments","getRouteInfo","applyRedirects","redirects","getStateFromPath","config","console","error","getNavigateAction","withAnchor","dangerouslySingular","__internal__PreviewKey","_actionState","_navigationState","singular","isPreviewNavigation","actionStateRoute","navigationState","rootPayload","initial","process","env","NODE_ENV","warn","expoParams","__internal__expo_router_is_preview_navigation","__internal_expo_router_no_animation","appendInternalExpoRouterParams","target","key","name","screen","_actionStateRoute","lookThroughAllTabs","actionState","navigationRoutes","stateRoute","find","route","childState","nextNavigationState","dynamicName","matchDynamicName","didActionAndCurrentStateDiverge"],"sources":["/Users/sbudhwar/workspace/github/tomanage/node_modules/expo-router/src/global-state/routing.ts"],"sourcesContent":["import {\n  NavigationAction,\n  type NavigationState,\n  PartialRoute,\n  type PartialState,\n  type NavigationContainerRef,\n  ParamListBase,\n} from '@react-navigation/native';\nimport { IS_DOM } from 'expo/dom';\nimport * as Linking from 'expo-linking';\nimport { type RefObject } from 'react';\nimport { Platform } from 'react-native';\n\nimport { store } from './router-store';\nimport {\n  emitDomDismiss,\n  emitDomDismissAll,\n  emitDomGoBack,\n  emitDomLinkEvent,\n  emitDomSetParams,\n} from '../domComponents/emitDomEvent';\nimport { ResultState } from '../fork/getStateFromPath';\nimport { applyRedirects } from '../getRoutesRedirects';\nimport { resolveHref, resolveHrefStringWithSegments } from '../link/href';\nimport { matchDynamicName } from '../matchers';\nimport { appendInternalExpoRouterParams, type InternalExpoRouterParams } from '../navigationParams';\nimport { Href } from '../types';\nimport { SingularOptions } from '../useScreens';\nimport { shouldLinkExternally } from '../utils/url';\n\nfunction assertIsReady() {\n  if (!store.navigationRef.isReady()) {\n    throw new Error(\n      'Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.'\n    );\n  }\n}\n\nexport const routingQueue = {\n  queue: [] as NavigationAction[],\n  subscribers: new Set<() => void>(),\n  subscribe(callback: () => void) {\n    routingQueue.subscribers.add(callback);\n    return () => {\n      routingQueue.subscribers.delete(callback);\n    };\n  },\n  snapshot() {\n    return routingQueue.queue;\n  },\n  add(action: NavigationAction) {\n    routingQueue.queue.push(action);\n    for (const callback of routingQueue.subscribers) {\n      callback();\n    }\n  },\n  run(ref: RefObject<NavigationContainerRef<ParamListBase> | null>) {\n    // Reset the identity of the queue.\n    const events = routingQueue.queue;\n    routingQueue.queue = [];\n    let action: NavigationAction | undefined;\n    while ((action = events.shift())) {\n      if (ref.current) {\n        ref.current.dispatch(action);\n      }\n    }\n  },\n};\n\nexport type NavigationOptions = Omit<LinkToOptions, 'event'>;\n\nexport function navigate(url: Href, options?: NavigationOptions) {\n  return linkTo(resolveHref(url), { ...options, event: 'NAVIGATE' });\n}\n\nexport function reload() {\n  // TODO(EvanBacon): add `reload` support.\n  throw new Error('The reload method is not implemented in the client-side router yet.');\n}\n\nexport function prefetch(href: Href, options?: NavigationOptions) {\n  return linkTo(resolveHref(href), { ...options, event: 'PRELOAD' });\n}\n\nexport function push(url: Href, options?: NavigationOptions) {\n  return linkTo(resolveHref(url), { ...options, event: 'PUSH' });\n}\n\nexport function dismiss(count: number = 1) {\n  if (emitDomDismiss(count)) {\n    return;\n  }\n\n  routingQueue.add({ type: 'POP', payload: { count } });\n}\n\nexport function dismissTo(href: Href, options?: NavigationOptions) {\n  return linkTo(resolveHref(href), { ...options, event: 'POP_TO' });\n}\n\nexport function replace(url: Href, options?: NavigationOptions) {\n  return linkTo(resolveHref(url), { ...options, event: 'REPLACE' });\n}\n\nexport function dismissAll() {\n  if (emitDomDismissAll()) {\n    return;\n  }\n  routingQueue.add({ type: 'POP_TO_TOP' });\n}\n\nexport function goBack() {\n  if (emitDomGoBack()) {\n    return;\n  }\n  assertIsReady();\n  routingQueue.add({ type: 'GO_BACK' });\n}\n\nexport function canGoBack(): boolean {\n  if (IS_DOM) {\n    throw new Error(\n      'canGoBack imperative method is not supported. Pass the property to the DOM component instead.'\n    );\n  }\n  // Return a default value here if the navigation hasn't mounted yet.\n  // This can happen if the user calls `canGoBack` from the Root Layout route\n  // before mounting a navigator. This behavior exists due to React Navigation being dynamically\n  // constructed at runtime. We can get rid of this in the future if we use\n  // the static configuration internally.\n  if (!store.navigationRef.isReady()) {\n    return false;\n  }\n  return store.navigationRef?.current?.canGoBack() ?? false;\n}\n\nexport function canDismiss(): boolean {\n  if (IS_DOM) {\n    throw new Error(\n      'canDismiss imperative method is not supported. Pass the property to the DOM component instead.'\n    );\n  }\n  let state = store.state;\n\n  // Keep traversing down the state tree until we find a stack navigator that we can pop\n  while (state) {\n    if (state.type === 'stack' && state.routes.length > 1) {\n      return true;\n    }\n    if (state.index === undefined) return false;\n\n    state = state.routes?.[state.index]?.state as any;\n  }\n\n  return false;\n}\n\nexport function setParams(\n  params: Record<string, undefined | string | number | (string | number)[]> = {}\n) {\n  if (emitDomSetParams(params)) {\n    return;\n  }\n  assertIsReady();\n  return (store.navigationRef?.current?.setParams as any)(params);\n}\n\nexport type LinkToOptions = {\n  event?: string;\n\n  /**\n   * Relative URL references are either relative to the directory or the document. By default, relative paths are relative to the document.\n   * @see: [MDN's documentation on Resolving relative references to a URL](https://developer.mozilla.org/en-US/docs/Web/API/URL_API/Resolving_relative_references).\n   */\n  relativeToDirectory?: boolean;\n\n  /**\n   * Include the anchor when navigating to a new navigator\n   */\n  withAnchor?: boolean;\n\n  /**\n   * When navigating in a Stack, remove all screen from the history that match the singular condition\n   *\n   * If used with `push`, the history will be filtered even if no navigation occurs.\n   */\n  dangerouslySingular?: SingularOptions;\n\n  __internal__PreviewKey?: string;\n};\n\nexport function linkTo(originalHref: Href, options: LinkToOptions = {}) {\n  originalHref = typeof originalHref == 'string' ? originalHref : resolveHref(originalHref);\n  let href: string | undefined | null = originalHref;\n\n  if (emitDomLinkEvent(href, options)) {\n    return;\n  }\n\n  if (shouldLinkExternally(href)) {\n    if (href.startsWith('//') && Platform.OS !== 'web') {\n      href = `https:${href}`;\n    }\n\n    Linking.openURL(href);\n    return;\n  }\n\n  assertIsReady();\n  const navigationRef = store.navigationRef.current;\n\n  if (navigationRef == null) {\n    throw new Error(\n      \"Couldn't find a navigation object. Is your component inside NavigationContainer?\"\n    );\n  }\n\n  if (!store.linking) {\n    throw new Error('Attempted to link to route when no routes are present');\n  }\n\n  if (href === '..' || href === '../') {\n    navigationRef.goBack();\n    return;\n  }\n\n  const rootState = navigationRef.getRootState();\n\n  href = resolveHrefStringWithSegments(href, store.getRouteInfo(), options);\n  href = applyRedirects(href, store.redirects);\n\n  // If the href is undefined, it means that the redirect has already been handled the navigation\n  if (!href) {\n    return;\n  }\n\n  const state = store.linking.getStateFromPath!(href, store.linking.config);\n\n  if (!state || state.routes.length === 0) {\n    console.error('Could not generate a valid navigation state for the given path: ' + href);\n    return;\n  }\n\n  routingQueue.add(\n    getNavigateAction(\n      state,\n      rootState,\n      options.event,\n      options.withAnchor,\n      options.dangerouslySingular,\n      !!options.__internal__PreviewKey\n    )\n  );\n}\n\nfunction getNavigateAction(\n  _actionState: ResultState,\n  _navigationState: NavigationState,\n  type = 'NAVIGATE',\n  withAnchor?: boolean,\n  singular?: SingularOptions,\n  isPreviewNavigation?: boolean\n) {\n  /**\n   * We need to find the deepest navigator where the action and current state diverge, If they do not diverge, the\n   * lowest navigator is the target.\n   *\n   * By default React Navigation will target the current navigator, but this doesn't work for all actions\n   * For example:\n   *  - /deeply/nested/route -> /top-level-route the target needs to be the top-level navigator\n   *  - /stack/nestedStack/page -> /stack1/nestedStack/other-page needs to target the nestedStack navigator\n   *\n   * This matching needs to done by comparing the route names and the dynamic path, for example\n   * - /1/page -> /2/anotherPage needs to target the /[id] navigator\n   *\n   * Other parameters such as search params and hash are not evaluated.\n   */\n\n  const { actionStateRoute, navigationState } = findDivergentState(\n    _actionState,\n    _navigationState,\n    type === 'PRELOAD'\n  );\n\n  /*\n   * We found the target navigator, but the payload is in the incorrect format\n   * We need to convert the action state to a payload that can be dispatched\n   */\n  const rootPayload = getPayloadFromStateRoute(actionStateRoute || {});\n\n  if (type === 'PUSH' && navigationState.type !== 'stack') {\n    type = 'NAVIGATE';\n  } else if (navigationState.type === 'expo-tab') {\n    type = 'JUMP_TO';\n  } else if (type === 'REPLACE' && navigationState.type === 'drawer') {\n    type = 'JUMP_TO';\n  }\n\n  if (withAnchor !== undefined) {\n    if (rootPayload.params.initial) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(`The parameter 'initial' is a reserved parameter name in React Navigation`);\n      }\n    }\n    /*\n     * The logic for initial can seen backwards depending on your perspective\n     *   True: The initialRouteName is not loaded. The incoming screen is the initial screen (default)\n     *   False: The initialRouteName is loaded. THe incoming screen is placed after the initialRouteName\n     *\n     * withAnchor flips the perspective.\n     *   True: You want the initialRouteName to load.\n     *   False: You do not want the initialRouteName to load.\n     */\n    rootPayload.params.initial = !withAnchor;\n  }\n\n  const expoParams: InternalExpoRouterParams = isPreviewNavigation\n    ? {\n        __internal__expo_router_is_preview_navigation: true,\n        __internal_expo_router_no_animation: true,\n      }\n    : {};\n  const params = appendInternalExpoRouterParams(rootPayload.params, expoParams);\n\n  return {\n    type,\n    target: navigationState.key,\n    payload: {\n      // key: rootPayload.key,\n      name: rootPayload.screen,\n      params,\n      singular,\n    },\n  };\n}\n\n/**\n * React Navigation uses params to store information about the screens, rather then create new state for each level.\n * This function traverses the action state that will not be part of state and returns a payload that can be used in action.\n */\nexport function getPayloadFromStateRoute(_actionStateRoute: PartialRoute<any>) {\n  const rootPayload: Record<string, any> = { params: {} };\n  let payload = rootPayload;\n  let params = payload.params;\n  let actionStateRoute: PartialRoute<any> | undefined = _actionStateRoute;\n\n  while (actionStateRoute) {\n    Object.assign(params, { ...payload.params, ...actionStateRoute.params });\n    // Assign the screen name to the payload\n    payload.screen = actionStateRoute.name;\n    // Merge the params, ensuring that we create a new object\n    payload.params = { ...params };\n\n    // Params don't include the screen, thats a separate attribute\n    delete payload.params['screen'];\n\n    // Continue down the payload tree\n    // Initially these values are separate, but React Nav merges them after the first layer\n    payload = payload.params;\n    params = payload;\n\n    actionStateRoute = actionStateRoute.state?.routes[actionStateRoute.state?.routes.length - 1];\n  }\n  return rootPayload;\n}\n\n/*\n * Traverse the state tree comparing the current state and the action state until we find where they diverge\n */\nexport function findDivergentState(\n  _actionState: ResultState,\n  _navigationState: NavigationState,\n  // If true, look through all tabs to find the target state, rather then just the current tab\n  lookThroughAllTabs: boolean = false\n) {\n  let actionState: PartialState<NavigationState> | undefined = _actionState;\n  let navigationState: NavigationState | undefined = _navigationState;\n  let actionStateRoute: PartialRoute<any> | undefined;\n  const navigationRoutes = [];\n  while (actionState && navigationState) {\n    actionStateRoute = actionState.routes[actionState.routes.length - 1];\n    const stateRoute = (() => {\n      if (navigationState.type === 'tab' && lookThroughAllTabs) {\n        return (\n          navigationState.routes.find((route) => route.name === actionStateRoute?.name) ||\n          navigationState.routes[navigationState.index ?? 0]\n        );\n      }\n      return navigationState.routes[navigationState.index ?? 0];\n    })();\n\n    const childState: PartialState<NavigationState> | undefined = actionStateRoute.state;\n    const nextNavigationState = stateRoute.state;\n\n    const dynamicName = matchDynamicName(actionStateRoute.name);\n\n    const didActionAndCurrentStateDiverge =\n      actionStateRoute.name !== stateRoute.name ||\n      !childState ||\n      !nextNavigationState ||\n      (dynamicName &&\n        // @ts-expect-error: TODO(@kitten): This isn't properly typed, so the index access fails\n        actionStateRoute.params?.[dynamicName.name] !== stateRoute.params?.[dynamicName.name]);\n\n    if (didActionAndCurrentStateDiverge) {\n      // If we are looking through all tabs, we need to add new tab id if this is the last route\n      // Otherwise we wouldn't be able to change the tab\n      if (navigationState.type === 'tab' && lookThroughAllTabs) {\n        navigationRoutes.push(stateRoute);\n      }\n      break;\n    }\n\n    navigationRoutes.push(stateRoute);\n\n    actionState = childState;\n    navigationState = nextNavigationState as NavigationState;\n  }\n\n  return {\n    actionState,\n    navigationState,\n    actionStateRoute,\n    navigationRoutes,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}