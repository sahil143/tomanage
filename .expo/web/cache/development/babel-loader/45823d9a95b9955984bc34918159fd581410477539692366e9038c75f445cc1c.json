{"ast":null,"code":"\"use strict\";\n'use client';\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function () {\n  var ownKeys = function (o) {\n    ownKeys = Object.getOwnPropertyNames || function (o) {\n      var ar = [];\n      for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n      return ar;\n    };\n    return ownKeys(o);\n  };\n  return function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n    __setModuleDefault(result, mod);\n    return result;\n  };\n}();\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.store = void 0;\nexports.useStore = useStore;\nexports.useRouteInfo = useRouteInfo;\nconst native_1 = require(\"@react-navigation/native\");\nconst expo_constants_1 = __importDefault(require(\"expo-constants\"));\nconst react_1 = require(\"react\");\nconst react_native_1 = require(\"react-native-web/dist/index\");\nconst extractPathFromURL_1 = require(\"../fork/extractPathFromURL\");\nconst getStateFromPath_forks_1 = require(\"../fork/getStateFromPath-forks\");\nconst getLinkingConfig_1 = require(\"../getLinkingConfig\");\nconst getReactNavigationConfig_1 = require(\"../getReactNavigationConfig\");\nconst getRoutes_1 = require(\"../getRoutes\");\nconst routeInfo_1 = require(\"./routeInfo\");\nconst href_1 = require(\"../link/href\");\nconst useScreens_1 = require(\"../useScreens\");\nconst PreviewRouteContext_1 = require(\"../link/preview/PreviewRouteContext\");\nconst url_1 = require(\"../utils/url\");\nconst SplashScreen = __importStar(require(\"../views/Splash\"));\nconst storeRef = {\n  current: {}\n};\nconst routeInfoCache = new WeakMap();\nconst routeInfoValuesCache = new Map();\nlet splashScreenAnimationFrame;\nlet hasAttemptedToHideSplash = false;\nexports.store = {\n  shouldShowTutorial() {\n    return !storeRef.current.routeNode && process.env.NODE_ENV === 'development';\n  },\n  get state() {\n    return storeRef.current.state;\n  },\n  get navigationRef() {\n    return storeRef.current.navigationRef;\n  },\n  get routeNode() {\n    return storeRef.current.routeNode;\n  },\n  getRouteInfo() {\n    return storeRef.current.routeInfo || routeInfo_1.defaultRouteInfo;\n  },\n  get redirects() {\n    return storeRef.current.redirects || [];\n  },\n  get rootComponent() {\n    return storeRef.current.rootComponent;\n  },\n  getStateForHref(href, options) {\n    href = (0, href_1.resolveHref)(href);\n    href = (0, href_1.resolveHrefStringWithSegments)(href, exports.store.getRouteInfo(), options);\n    return this.linking?.getStateFromPath(href, this.linking.config);\n  },\n  get linking() {\n    return storeRef.current.linking;\n  },\n  setFocusedState(state) {\n    const routeInfo = getCachedRouteInfo(state);\n    storeRef.current.routeInfo = routeInfo;\n  },\n  onReady() {\n    if (!hasAttemptedToHideSplash) {\n      hasAttemptedToHideSplash = true;\n      splashScreenAnimationFrame = requestAnimationFrame(() => {\n        SplashScreen._internal_maybeHideAsync?.();\n      });\n    }\n    storeRef.current.navigationRef.addListener('state', e => {\n      if (!e.data.state) {\n        return;\n      }\n      let isStale = false;\n      let state = e.data.state;\n      while (!isStale && state) {\n        isStale = state.stale;\n        state = state.routes?.['index' in state && typeof state.index === 'number' ? state.index : state.routes.length - 1]?.state;\n      }\n      storeRef.current.state = e.data.state;\n      if (!isStale) {\n        storeRef.current.routeInfo = getCachedRouteInfo(e.data.state);\n      }\n      for (const callback of routeInfoSubscribers) {\n        callback();\n      }\n    });\n  },\n  assertIsReady() {\n    if (!storeRef.current.navigationRef.isReady()) {\n      throw new Error('Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.');\n    }\n  }\n};\nfunction useStore(context, linkingConfigOptions, serverUrl) {\n  const navigationRef = (0, native_1.useNavigationContainerRef)();\n  const config = expo_constants_1.default.expoConfig?.extra?.router;\n  let linking;\n  let rootComponent = react_1.Fragment;\n  let initialState;\n  const routeNode = (0, getRoutes_1.getRoutes)(context, Object.assign({}, config, {\n    skipGenerated: true,\n    ignoreEntryPoints: true,\n    platform: react_native_1.Platform.OS,\n    preserveRedirectAndRewrites: true\n  }));\n  const redirects = [config?.redirects, config?.rewrites].filter(Boolean).flat().map(route => {\n    return [(0, getStateFromPath_forks_1.routePatternToRegex)((0, getReactNavigationConfig_1.parseRouteSegments)(route.source)), route, (0, url_1.shouldLinkExternally)(route.destination)];\n  });\n  if (routeNode) {\n    linking = (0, getLinkingConfig_1.getLinkingConfig)(routeNode, context, () => exports.store.getRouteInfo(), {\n      metaOnly: linkingConfigOptions.metaOnly,\n      serverUrl,\n      redirects,\n      skipGenerated: config?.skipGenerated ?? false,\n      sitemap: config?.sitemap ?? true,\n      notFound: config?.notFound ?? true\n    });\n    rootComponent = (0, useScreens_1.getQualifiedRouteComponent)(routeNode);\n    const initialURL = linking?.getInitialURL?.();\n    if (typeof initialURL === 'string') {\n      let initialPath = (0, extractPathFromURL_1.extractExpoPathFromURL)(linking.prefixes, initialURL);\n      if (!initialPath.startsWith('/')) initialPath = '/' + initialPath;\n      initialState = linking.getStateFromPath(initialPath, linking.config);\n      const initialRouteInfo = (0, routeInfo_1.getRouteInfoFromState)(initialState);\n      routeInfoCache.set(initialState, initialRouteInfo);\n      routeInfoValuesCache.set(JSON.stringify(initialRouteInfo), initialRouteInfo);\n    }\n  } else {\n    if (process.env.NODE_ENV === 'production') {\n      throw new Error('No routes found');\n    }\n    rootComponent = react_1.Fragment;\n  }\n  storeRef.current = {\n    navigationRef,\n    routeNode,\n    config,\n    rootComponent,\n    linking,\n    redirects,\n    state: initialState\n  };\n  if (initialState) {\n    storeRef.current.routeInfo = getCachedRouteInfo(initialState);\n  }\n  (0, react_1.useEffect)(() => {\n    return () => {\n      if (splashScreenAnimationFrame) {\n        cancelAnimationFrame(splashScreenAnimationFrame);\n        splashScreenAnimationFrame = undefined;\n      }\n    };\n  });\n  return exports.store;\n}\nconst routeInfoSubscribers = new Set();\nconst routeInfoSubscribe = callback => {\n  routeInfoSubscribers.add(callback);\n  return () => {\n    routeInfoSubscribers.delete(callback);\n  };\n};\nfunction useRouteInfo() {\n  const routeInfo = (0, react_1.useSyncExternalStore)(routeInfoSubscribe, exports.store.getRouteInfo, exports.store.getRouteInfo);\n  const {\n    isPreview,\n    segments,\n    params,\n    pathname\n  } = (0, PreviewRouteContext_1.usePreviewInfo)();\n  if (isPreview) {\n    return {\n      pathname: pathname ?? '',\n      segments: segments ?? [],\n      unstable_globalHref: '',\n      params: params ?? {},\n      searchParams: new URLSearchParams(),\n      pathnameWithParams: pathname ?? '',\n      isIndex: false\n    };\n  }\n  return routeInfo;\n}\nfunction getCachedRouteInfo(state) {\n  let routeInfo = routeInfoCache.get(state);\n  if (!routeInfo) {\n    routeInfo = (0, routeInfo_1.getRouteInfoFromState)(state);\n    const routeInfoString = JSON.stringify(routeInfo);\n    const cachedRouteInfo = routeInfoValuesCache.get(routeInfoString);\n    if (cachedRouteInfo) {\n      routeInfo = cachedRouteInfo;\n    } else {\n      routeInfoValuesCache.set(routeInfoString, routeInfo);\n    }\n    routeInfoCache.set(state, routeInfo);\n  }\n  return routeInfo;\n}","map":{"version":3,"names":["exports","useStore","useRouteInfo","native_1","require","expo_constants_1","__importDefault","react_1","react_native_1","extractPathFromURL_1","getStateFromPath_forks_1","getLinkingConfig_1","getReactNavigationConfig_1","getRoutes_1","routeInfo_1","href_1","useScreens_1","PreviewRouteContext_1","url_1","SplashScreen","__importStar","storeRef","current","routeInfoCache","WeakMap","routeInfoValuesCache","Map","splashScreenAnimationFrame","hasAttemptedToHideSplash","store","shouldShowTutorial","routeNode","process","env","NODE_ENV","state","navigationRef","getRouteInfo","routeInfo","defaultRouteInfo","redirects","rootComponent","getStateForHref","href","options","resolveHref","resolveHrefStringWithSegments","linking","getStateFromPath","config","setFocusedState","getCachedRouteInfo","onReady","requestAnimationFrame","_internal_maybeHideAsync","addListener","e","data","isStale","stale","routes","index","length","callback","routeInfoSubscribers","assertIsReady","isReady","Error","context","linkingConfigOptions","serverUrl","useNavigationContainerRef","default","expoConfig","extra","router","Fragment","initialState","getRoutes","Object","assign","skipGenerated","ignoreEntryPoints","platform","Platform","OS","preserveRedirectAndRewrites","rewrites","filter","Boolean","flat","map","route","routePatternToRegex","parseRouteSegments","source","shouldLinkExternally","destination","getLinkingConfig","metaOnly","sitemap","notFound","getQualifiedRouteComponent","initialURL","getInitialURL","initialPath","extractExpoPathFromURL","prefixes","startsWith","initialRouteInfo","getRouteInfoFromState","set","JSON","stringify","useEffect","cancelAnimationFrame","undefined","Set","routeInfoSubscribe","add","delete","useSyncExternalStore","isPreview","segments","params","pathname","usePreviewInfo","unstable_globalHref","searchParams","URLSearchParams","pathnameWithParams","isIndex","get","routeInfoString","cachedRouteInfo"],"sources":["/Users/sbudhwar/workspace/github/tomanage/node_modules/expo-router/src/global-state/router-store.tsx"],"sourcesContent":["'use client';\n\nimport {\n  NavigationContainerRefWithCurrent,\n  NavigationState,\n  PartialState,\n  useNavigationContainerRef,\n  useStateForPath,\n} from '@react-navigation/native';\nimport Constants from 'expo-constants';\nimport { ComponentType, Fragment, useEffect, useSyncExternalStore } from 'react';\nimport { Platform } from 'react-native';\n\nimport { RouteNode } from '../Route';\nimport { extractExpoPathFromURL } from '../fork/extractPathFromURL';\nimport { routePatternToRegex } from '../fork/getStateFromPath-forks';\nimport { ExpoLinkingOptions, LinkingConfigOptions, getLinkingConfig } from '../getLinkingConfig';\nimport { parseRouteSegments } from '../getReactNavigationConfig';\nimport { getRoutes } from '../getRoutes';\nimport { RedirectConfig } from '../getRoutesCore';\nimport { defaultRouteInfo, getRouteInfoFromState, UrlObject } from './routeInfo';\nimport { resolveHref, resolveHrefStringWithSegments } from '../link/href';\nimport { RequireContext, type Href } from '../types';\nimport { getQualifiedRouteComponent } from '../useScreens';\nimport { type LinkToOptions } from './routing';\nimport { usePreviewInfo } from '../link/preview/PreviewRouteContext';\nimport { shouldLinkExternally } from '../utils/url';\nimport * as SplashScreen from '../views/Splash';\n\nexport type StoreRedirects = readonly [RegExp, RedirectConfig, boolean];\nexport type ReactNavigationState = NavigationState | PartialState<NavigationState>;\nexport type FocusedRouteState = NonNullable<ReturnType<typeof useStateForPath>>;\n\nexport type RouterStore = typeof store;\n\ntype StoreRef = {\n  navigationRef: NavigationContainerRefWithCurrent<ReactNavigation.RootParamList>;\n  routeNode: RouteNode | null;\n  rootComponent: ComponentType<any>;\n  state?: ReactNavigationState;\n  linking?: ExpoLinkingOptions;\n  config: any;\n  redirects: StoreRedirects[];\n  routeInfo?: UrlObject;\n};\n\nconst storeRef = {\n  current: {} as StoreRef,\n};\n\nconst routeInfoCache = new WeakMap<FocusedRouteState | ReactNavigationState, UrlObject>();\nconst routeInfoValuesCache = new Map<string, UrlObject>();\n\nlet splashScreenAnimationFrame: number | undefined;\nlet hasAttemptedToHideSplash = false;\n\nexport const store = {\n  shouldShowTutorial() {\n    return !storeRef.current.routeNode && process.env.NODE_ENV === 'development';\n  },\n  get state() {\n    return storeRef.current.state;\n  },\n  get navigationRef() {\n    return storeRef.current.navigationRef;\n  },\n  get routeNode() {\n    return storeRef.current.routeNode;\n  },\n  getRouteInfo(): UrlObject {\n    return storeRef.current.routeInfo || defaultRouteInfo;\n  },\n  get redirects() {\n    return storeRef.current.redirects || [];\n  },\n  get rootComponent() {\n    return storeRef.current.rootComponent;\n  },\n  getStateForHref(href: Href, options?: LinkToOptions) {\n    href = resolveHref(href);\n\n    href = resolveHrefStringWithSegments(href, store.getRouteInfo(), options);\n    return this.linking?.getStateFromPath!(href, this.linking.config);\n  },\n  get linking() {\n    return storeRef.current.linking;\n  },\n  setFocusedState(state: FocusedRouteState) {\n    const routeInfo = getCachedRouteInfo(state);\n    storeRef.current.routeInfo = routeInfo;\n  },\n  onReady() {\n    if (!hasAttemptedToHideSplash) {\n      hasAttemptedToHideSplash = true;\n      // NOTE(EvanBacon): `navigationRef.isReady` is sometimes not true when state is called initially.\n      splashScreenAnimationFrame = requestAnimationFrame(() => {\n        SplashScreen._internal_maybeHideAsync?.();\n      });\n    }\n\n    storeRef.current.navigationRef.addListener('state', (e) => {\n      if (!e.data.state) {\n        return;\n      }\n\n      let isStale: boolean | undefined = false;\n      let state: ReactNavigationState | undefined = e.data.state;\n\n      while (!isStale && state) {\n        isStale = state.stale;\n        state =\n          state.routes?.[\n            'index' in state && typeof state.index === 'number'\n              ? state.index\n              : state.routes.length - 1\n          ]?.state;\n      }\n\n      storeRef.current.state = e.data.state;\n\n      if (!isStale) {\n        storeRef.current.routeInfo = getCachedRouteInfo(e.data.state);\n      }\n\n      for (const callback of routeInfoSubscribers) {\n        callback();\n      }\n    });\n  },\n  assertIsReady() {\n    if (!storeRef.current.navigationRef.isReady()) {\n      throw new Error(\n        'Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.'\n      );\n    }\n  },\n};\n\nexport function useStore(\n  context: RequireContext,\n  linkingConfigOptions: LinkingConfigOptions,\n  serverUrl?: string\n) {\n  const navigationRef = useNavigationContainerRef();\n  const config = Constants.expoConfig?.extra?.router;\n\n  let linking: ExpoLinkingOptions | undefined;\n  let rootComponent: ComponentType<any> = Fragment;\n  let initialState: ReactNavigationState | undefined;\n\n  const routeNode = getRoutes(context, {\n    ...config,\n    skipGenerated: true,\n    ignoreEntryPoints: true,\n    platform: Platform.OS,\n    preserveRedirectAndRewrites: true,\n  });\n\n  const redirects: StoreRedirects[] = [config?.redirects, config?.rewrites]\n    .filter(Boolean)\n    .flat()\n    .map((route) => {\n      return [\n        routePatternToRegex(parseRouteSegments(route.source)),\n        route,\n        shouldLinkExternally(route.destination),\n      ];\n    });\n\n  if (routeNode) {\n    // We have routes, so get the linking config and the root component\n    linking = getLinkingConfig(routeNode, context, () => store.getRouteInfo(), {\n      metaOnly: linkingConfigOptions.metaOnly,\n      serverUrl,\n      redirects,\n      skipGenerated: config?.skipGenerated ?? false,\n      sitemap: config?.sitemap ?? true,\n      notFound: config?.notFound ?? true,\n    });\n    rootComponent = getQualifiedRouteComponent(routeNode);\n\n    // By default React Navigation is async and does not render anything in the first pass as it waits for `getInitialURL`\n    // This will cause static rendering to fail, which once performs a single pass.\n    // If the initialURL is a string, we can prefetch the state and routeInfo, skipping React Navigation's async behavior.\n    const initialURL = linking?.getInitialURL?.();\n    if (typeof initialURL === 'string') {\n      let initialPath = extractExpoPathFromURL(linking.prefixes, initialURL);\n\n      // It does not matter if the path starts with a `/` or not, but this keeps the behavior consistent\n      if (!initialPath.startsWith('/')) initialPath = '/' + initialPath;\n\n      initialState = linking.getStateFromPath(initialPath, linking.config);\n      const initialRouteInfo = getRouteInfoFromState(initialState);\n      routeInfoCache.set(initialState as any, initialRouteInfo);\n      routeInfoValuesCache.set(JSON.stringify(initialRouteInfo), initialRouteInfo);\n    }\n  } else {\n    // Only error in production, in development we will show the onboarding screen\n    if (process.env.NODE_ENV === 'production') {\n      throw new Error('No routes found');\n    }\n\n    // In development, we will show the onboarding screen\n    rootComponent = Fragment;\n  }\n\n  storeRef.current = {\n    navigationRef,\n    routeNode,\n    config,\n    rootComponent,\n    linking,\n    redirects,\n    state: initialState,\n  };\n\n  if (initialState) {\n    storeRef.current.routeInfo = getCachedRouteInfo(initialState);\n  }\n\n  useEffect(() => {\n    return () => {\n      // listener();\n\n      if (splashScreenAnimationFrame) {\n        cancelAnimationFrame(splashScreenAnimationFrame);\n        splashScreenAnimationFrame = undefined;\n      }\n    };\n  });\n\n  return store;\n}\n\nconst routeInfoSubscribers = new Set<() => void>();\nconst routeInfoSubscribe = (callback: () => void) => {\n  routeInfoSubscribers.add(callback);\n  return () => {\n    routeInfoSubscribers.delete(callback);\n  };\n};\n\nexport function useRouteInfo(): UrlObject {\n  const routeInfo = useSyncExternalStore(\n    routeInfoSubscribe,\n    store.getRouteInfo,\n    store.getRouteInfo\n  );\n  const { isPreview, segments, params, pathname } = usePreviewInfo();\n  if (isPreview) {\n    return {\n      pathname: pathname ?? '',\n      segments: segments ?? [],\n      unstable_globalHref: '',\n      params: params ?? {},\n      searchParams: new URLSearchParams(),\n      pathnameWithParams: pathname ?? '',\n      isIndex: false,\n    };\n  }\n  return routeInfo;\n}\n\nfunction getCachedRouteInfo(state: ReactNavigationState) {\n  let routeInfo = routeInfoCache.get(state);\n\n  if (!routeInfo) {\n    routeInfo = getRouteInfoFromState(state);\n\n    const routeInfoString = JSON.stringify(routeInfo);\n    // Using cached values to avoid re-renders, to increase the chance that the object reference is the same\n    const cachedRouteInfo = routeInfoValuesCache.get(routeInfoString);\n\n    if (cachedRouteInfo) {\n      routeInfo = cachedRouteInfo;\n    } else {\n      routeInfoValuesCache.set(routeInfoString, routeInfo);\n    }\n\n    routeInfoCache.set(state, routeInfo);\n  }\n\n  return routeInfo;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}