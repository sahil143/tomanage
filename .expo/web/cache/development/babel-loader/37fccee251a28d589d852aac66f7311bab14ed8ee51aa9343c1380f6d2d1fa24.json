{"ast":null,"code":"\"use strict\";\n'use client';\n\nvar _reactJsxDevRuntime = require(\"react/jsx-dev-runtime\");\nvar _jsxFileName = \"/Users/sbudhwar/workspace/github/tomanage/node_modules/expo-router/build/layouts/StackClient.js\";\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StackRouter = exports.stackRouterOverride = void 0;\nconst native_1 = require(\"@react-navigation/native\");\nconst non_secure_1 = require(\"nanoid/non-secure\");\nconst react_1 = require(\"react\");\nconst withLayoutContext_1 = require(\"./withLayoutContext\");\nconst createNativeStackNavigator_1 = require(\"../fork/native-stack/createNativeStackNavigator\");\nconst LinkPreviewContext_1 = require(\"../link/preview/LinkPreviewContext\");\nconst navigationParams_1 = require(\"../navigationParams\");\nconst useScreens_1 = require(\"../useScreens\");\nconst Protected_1 = require(\"../views/Protected\");\nconst NativeStackNavigator = (0, createNativeStackNavigator_1.createNativeStackNavigator)().Navigator;\nconst RNStack = (0, withLayoutContext_1.withLayoutContext)(NativeStackNavigator);\nfunction isStackAction(action) {\n  return action.type === 'PUSH' || action.type === 'NAVIGATE' || action.type === 'POP' || action.type === 'POP_TO_TOP' || action.type === 'REPLACE' || action.type === 'PRELOAD';\n}\nconst isPreviewAction = action => !!action.payload && 'params' in action.payload && typeof action.payload.params === 'object' && !!(0, navigationParams_1.getInternalExpoRouterParams)(action.payload?.params ?? undefined)['__internal__expo_router_is_preview_navigation'];\nconst stackRouterOverride = original => {\n  return {\n    getStateForAction: (state, action, options) => {\n      if (action.target && action.target !== state.key) {\n        return null;\n      }\n      if (!isStackAction(action)) {\n        return original.getStateForAction(state, action, options);\n      }\n      const actionSingularOptions = action.payload && 'singular' in action.payload ? action.payload.singular : undefined;\n      function getIdFunction() {\n        if (!('payload' in action) || !action.payload || !('name' in action.payload) || typeof action.payload.name !== 'string') {\n          return;\n        }\n        const actionName = action.payload.name;\n        return (getActionSingularIdFn(actionSingularOptions, actionName) || options.routeGetIdList[actionName]\n        );\n      }\n      const {\n        routeParamList\n      } = options;\n      switch (action.type) {\n        case 'PUSH':\n        case 'NAVIGATE':\n          {\n            if (!state.routeNames.includes(action.payload.name)) {\n              return null;\n            }\n            const getId = getIdFunction();\n            const id = getId?.({\n              params: action.payload.params\n            });\n            let route;\n            if (id !== undefined) {\n              route = state.routes.findLast(route => route.name === action.payload.name && id === getId?.({\n                params: route.params\n              }));\n            } else if (action.type === 'NAVIGATE') {\n              const currentRoute = state.routes[state.index];\n              if (action.payload.name === currentRoute.name && !isPreviewAction(action)) {\n                route = currentRoute;\n              } else if (action.payload.pop) {\n                route = state.routes.findLast(route => route.name === action.payload.name);\n              }\n            }\n            if (isPreviewAction(action) && !route) {\n              route = state.preloadedRoutes.find(route => route.name === action.payload.name && id === route.key);\n            }\n            if (!route) {\n              route = state.preloadedRoutes.find(route => route.name === action.payload.name && id === getId?.({\n                params: route.params\n              }));\n            }\n            let params;\n            if (action.type === 'NAVIGATE' && action.payload.merge && route) {\n              params = action.payload.params !== undefined || routeParamList[action.payload.name] !== undefined ? Object.assign({}, routeParamList[action.payload.name], route.params, action.payload.params) : route.params;\n            } else {\n              params = routeParamList[action.payload.name] !== undefined ? Object.assign({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params;\n            }\n            let routes;\n            if (route) {\n              if (action.type === 'NAVIGATE' && action.payload.pop) {\n                routes = [];\n                for (const r of state.routes) {\n                  if (r.key === route.key) {\n                    routes.push(Object.assign({}, route, {\n                      path: action.payload.path !== undefined ? action.payload.path : route.path,\n                      params\n                    }));\n                    break;\n                  }\n                  routes.push(r);\n                }\n              } else {\n                if (id !== undefined) {\n                  routes = state.routes.filter(r => r.key !== route.key);\n                } else if (action.type === 'NAVIGATE' && state.routes.length > 0) {\n                  const lastRoute = state.routes[state.routes.length - 1];\n                  if ((0, useScreens_1.getSingularId)(lastRoute.name, {\n                    params: lastRoute.params\n                  }) === (0, useScreens_1.getSingularId)(route.name, {\n                    params\n                  })) {\n                    routes = state.routes.slice(0, -1);\n                  } else {\n                    routes = [...state.routes];\n                  }\n                } else {\n                  routes = [...state.routes];\n                }\n                const key = routes.length === state.routes.length && !isPreviewAction(action) ? `${action.payload.name}-${(0, non_secure_1.nanoid)()}` : route.key;\n                routes.push(Object.assign({}, route, {\n                  key,\n                  path: action.type === 'NAVIGATE' && action.payload.path !== undefined ? action.payload.path : route.path,\n                  params\n                }));\n              }\n            } else {\n              routes = [...state.routes, {\n                key: `${action.payload.name}-${(0, non_secure_1.nanoid)()}`,\n                name: action.payload.name,\n                path: action.type === 'NAVIGATE' ? action.payload.path : undefined,\n                params\n              }];\n            }\n            const result = Object.assign({}, state, {\n              index: routes.length - 1,\n              preloadedRoutes: state.preloadedRoutes.filter(route => routes[routes.length - 1].key !== route.key),\n              routes\n            });\n            if (actionSingularOptions) {\n              return filterSingular(result, getId);\n            }\n            return result;\n          }\n        case 'PRELOAD':\n          {\n            if (!state.routeNames.includes(action.payload.name)) {\n              return null;\n            }\n            const getId = options.routeGetIdList[action.payload.name];\n            const id = getId?.({\n              params: action.payload.params\n            });\n            let route;\n            if (id !== undefined) {\n              route = state.routes.find(route => route.name === action.payload.name && id === getId?.({\n                params: route.params\n              }));\n            }\n            if (route) {\n              return Object.assign({}, state, {\n                routes: state.routes.map(r => {\n                  if (r.key !== route?.key) {\n                    return r;\n                  }\n                  return Object.assign({}, r, {\n                    params: routeParamList[action.payload.name] !== undefined ? Object.assign({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params\n                  });\n                })\n              });\n            } else {\n              const currentPreloadedRoute = {\n                key: `${action.payload.name}-${(0, non_secure_1.nanoid)()}`,\n                name: action.payload.name,\n                params: routeParamList[action.payload.name] !== undefined ? Object.assign({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params\n              };\n              return Object.assign({}, state, {\n                preloadedRoutes: [currentPreloadedRoute].concat(state.preloadedRoutes.filter(r => r.name !== action.payload.name || id !== getId?.({\n                  params: r.params\n                })))\n              });\n            }\n          }\n        default:\n          {\n            return original.getStateForAction(state, action, options);\n          }\n      }\n    }\n  };\n};\nexports.stackRouterOverride = stackRouterOverride;\nfunction getActionSingularIdFn(actionGetId, name) {\n  if (typeof actionGetId === 'function') {\n    return options => actionGetId(name, options.params ?? {});\n  } else if (actionGetId === true) {\n    return options => (0, useScreens_1.getSingularId)(name, options);\n  }\n  return undefined;\n}\nfunction filterSingular(state, getId) {\n  if (!state) {\n    return state;\n  }\n  if (!state.routes) {\n    return state;\n  }\n  const currentIndex = state.index || state.routes.length - 1;\n  const current = state.routes[currentIndex];\n  const name = current.name;\n  const id = getId?.({\n    params: current.params\n  });\n  if (!id) {\n    return state;\n  }\n  let routes = state.routes;\n  routes = routes.filter((route, index) => {\n    if (index === currentIndex) {\n      return true;\n    }\n    return name !== route.name || id !== getId?.({\n      params: route.params\n    });\n  });\n  return Object.assign({}, state, {\n    index: routes.length - 1,\n    routes\n  });\n}\nconst Stack = Object.assign(props => {\n  const {\n    isStackAnimationDisabled\n  } = (0, LinkPreviewContext_1.useLinkPreviewContext)();\n  const screenOptions = (0, react_1.useMemo)(() => {\n    const condition = isStackAnimationDisabled ? () => true : shouldDisableAnimationBasedOnParams;\n    return disableAnimationInScreenOptions(props.screenOptions, condition);\n  }, [props.screenOptions, isStackAnimationDisabled]);\n  return _reactJsxDevRuntime.jsxDEV(RNStack, Object.assign({}, props, {\n    screenOptions: screenOptions,\n    UNSTABLE_router: exports.stackRouterOverride\n  }), void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 349,\n    columnNumber: 13\n  }, this);\n}, {\n  Screen: RNStack.Screen,\n  Protected: Protected_1.Protected\n});\nfunction disableAnimationInScreenOptions(options, condition) {\n  if (options && typeof options === 'function') {\n    return props => {\n      const oldOptions = options(props);\n      if (condition(props.route)) {\n        return Object.assign({}, oldOptions, {\n          animation: 'none'\n        });\n      }\n      return oldOptions ?? {};\n    };\n  }\n  return props => {\n    if (condition(props.route)) {\n      return Object.assign({}, options ?? {}, {\n        animation: 'none'\n      });\n    }\n    return options ?? {};\n  };\n}\nfunction shouldDisableAnimationBasedOnParams(route) {\n  const expoParams = (0, navigationParams_1.getInternalExpoRouterParams)(route.params);\n  return !!expoParams.__internal_expo_router_no_animation;\n}\nexports.default = Stack;\nconst StackRouter = options => {\n  const router = (0, native_1.StackRouter)(options);\n  return Object.assign({}, router, (0, exports.stackRouterOverride)(router));\n};\nexports.StackRouter = StackRouter;","map":{"version":3,"names":["_reactJsxDevRuntime","require","_jsxFileName","native_1","non_secure_1","react_1","withLayoutContext_1","createNativeStackNavigator_1","LinkPreviewContext_1","navigationParams_1","useScreens_1","Protected_1","NativeStackNavigator","createNativeStackNavigator","Navigator","RNStack","withLayoutContext","isStackAction","action","type","isPreviewAction","payload","params","getInternalExpoRouterParams","undefined","stackRouterOverride","original","getStateForAction","state","options","target","key","actionSingularOptions","singular","getIdFunction","name","actionName","getActionSingularIdFn","routeGetIdList","routeParamList","routeNames","includes","getId","id","route","routes","findLast","currentRoute","index","pop","preloadedRoutes","find","merge","Object","assign","r","push","path","filter","length","lastRoute","getSingularId","slice","nanoid","result","filterSingular","map","currentPreloadedRoute","concat","exports","actionGetId","currentIndex","current","Stack","props","isStackAnimationDisabled","useLinkPreviewContext","screenOptions","useMemo","condition","shouldDisableAnimationBasedOnParams","disableAnimationInScreenOptions","jsxDEV","UNSTABLE_router","fileName","lineNumber","columnNumber","Screen","Protected","oldOptions","animation","expoParams","__internal_expo_router_no_animation","default","StackRouter","router"],"sources":["/Users/sbudhwar/workspace/github/tomanage/node_modules/expo-router/src/layouts/StackClient.tsx"],"sourcesContent":["'use client';\nimport {\n  CommonNavigationAction,\n  NavigationAction,\n  ParamListBase,\n  PartialRoute,\n  PartialState,\n  Route,\n  RouterConfigOptions,\n  StackRouter as RNStackRouter,\n  StackActionType,\n  StackNavigationState,\n  type RouteProp,\n} from '@react-navigation/native';\nimport {\n  NativeStackNavigationEventMap,\n  NativeStackNavigationOptions,\n} from '@react-navigation/native-stack';\nimport { nanoid } from 'nanoid/non-secure';\nimport { ComponentProps, useMemo } from 'react';\n\nimport { withLayoutContext } from './withLayoutContext';\nimport { createNativeStackNavigator } from '../fork/native-stack/createNativeStackNavigator';\nimport { useLinkPreviewContext } from '../link/preview/LinkPreviewContext';\nimport { getInternalExpoRouterParams, type InternalExpoRouterParams } from '../navigationParams';\nimport { SingularOptions, getSingularId } from '../useScreens';\nimport { Protected } from '../views/Protected';\n\ntype GetId = NonNullable<RouterConfigOptions['routeGetIdList'][string]>;\n\nconst NativeStackNavigator = createNativeStackNavigator().Navigator;\n\n/**\n * We extend NativeStackNavigationOptions with our custom props\n * to allow for several extra props to be used on web, like modalWidth\n */\nexport type ExtendedStackNavigationOptions = NativeStackNavigationOptions & {\n  webModalStyle?: {\n    /**\n     * Override the width of the modal (px or percentage). Only applies on web platform.\n     * @platform web\n     */\n    width?: number | string;\n    /**\n     * Override the height of the modal (px or percentage). Applies on web desktop.\n     * @platform web\n     */\n    height?: number | string;\n    /**\n     * Minimum height of the desktop modal (px or percentage). Overrides the default 640px clamp.\n     * @platform web\n     */\n    minHeight?: number | string;\n    /**\n     * Minimum width of the desktop modal (px or percentage). Overrides the default 580px.\n     * @platform web\n     */\n    minWidth?: number | string;\n    /**\n     * Override the border of the desktop modal (any valid CSS border value, e.g. '1px solid #ccc' or 'none').\n     * @platform web\n     */\n    border?: string;\n    /**\n     * Override the overlay background color (any valid CSS color or rgba/hsla value).\n     * @platform web\n     */\n    overlayBackground?: string;\n    /**\n     * Override the modal shadow filter (any valid CSS filter value, e.g. 'drop-shadow(0 4px 8px rgba(0,0,0,0.1))' or 'none').\n     * @platform web\n     */\n    shadow?: string;\n  };\n};\n\nconst RNStack = withLayoutContext<\n  ExtendedStackNavigationOptions,\n  typeof NativeStackNavigator,\n  StackNavigationState<ParamListBase>,\n  NativeStackNavigationEventMap\n>(NativeStackNavigator);\n\ntype RNNavigationAction = Extract<CommonNavigationAction, { type: 'NAVIGATE' }>;\ntype RNPreloadAction = Extract<CommonNavigationAction, { type: 'PRELOAD' }>;\ntype ExpoNavigationAction = Omit<RNNavigationAction, 'payload'> & {\n  payload: Omit<RNNavigationAction['payload'], 'params'> & {\n    params: RNNavigationAction['payload']['params'] & InternalExpoRouterParams;\n  };\n};\n\nfunction isStackAction(\n  action: NavigationAction\n): action is StackActionType | RNPreloadAction | ExpoNavigationAction {\n  return (\n    action.type === 'PUSH' ||\n    action.type === 'NAVIGATE' ||\n    action.type === 'POP' ||\n    action.type === 'POP_TO_TOP' ||\n    action.type === 'REPLACE' ||\n    action.type === 'PRELOAD'\n  );\n}\n\nconst isPreviewAction = (action: NavigationAction): action is ExpoNavigationAction =>\n  !!action.payload &&\n  'params' in action.payload &&\n  typeof action.payload.params === 'object' &&\n  !!getInternalExpoRouterParams(action.payload?.params ?? undefined)[\n    '__internal__expo_router_is_preview_navigation'\n  ];\n\n/**\n * React Navigation matches a screen by its name or a 'getID' function that uniquely identifies a screen.\n * When a screen has been uniquely identified, the Stack can only have one instance of that screen.\n *\n * Expo Router allows for a screen to be matched by name and path params, a 'getID' function or a singular id.\n *\n * Instead of reimplementing the entire StackRouter, we can override the getStateForAction method to handle the singular screen logic.\n *\n */\nexport const stackRouterOverride: NonNullable<ComponentProps<typeof RNStack>['UNSTABLE_router']> = (\n  original\n) => {\n  return {\n    getStateForAction: (state, action, options) => {\n      if (action.target && action.target !== state.key) {\n        return null;\n      }\n\n      if (!isStackAction(action)) {\n        return original.getStateForAction(state, action, options);\n      }\n\n      // The dynamic getId added to an action, `router.push('screen', { singular: true })`\n      const actionSingularOptions =\n        action.payload && 'singular' in action.payload\n          ? (action.payload.singular as SingularOptions)\n          : undefined;\n\n      // Handle if 'getID' or 'singular' is set.\n      function getIdFunction(): GetId | undefined {\n        // Actions can be fired by the user, so we do need to validate their structure.\n        if (\n          !('payload' in action) ||\n          !action.payload ||\n          !('name' in action.payload) ||\n          typeof action.payload.name !== 'string'\n        ) {\n          return;\n        }\n\n        const actionName = action.payload.name;\n\n        return (\n          // The dynamic singular added to an action, `router.push('screen', { singular: () => 'id' })`\n          getActionSingularIdFn(actionSingularOptions, actionName) ||\n          // The static getId added as a prop to `<Screen singular />` or `<Screen getId={} />`\n          options.routeGetIdList[actionName]\n        );\n      }\n\n      const { routeParamList } = options;\n\n      switch (action.type) {\n        case 'PUSH':\n        case 'NAVIGATE': {\n          if (!state.routeNames.includes(action.payload.name)) {\n            return null;\n          }\n\n          // START FORK\n          const getId = getIdFunction();\n          // const getId = options.routeGetIdList[action.payload.name];\n          // END FORK\n          const id = getId?.({ params: action.payload.params });\n\n          let route: Route<string> | undefined;\n\n          if (id !== undefined) {\n            route = state.routes.findLast(\n              (route) =>\n                route.name === action.payload.name && id === getId?.({ params: route.params })\n            );\n          } else if (action.type === 'NAVIGATE') {\n            const currentRoute = state.routes[state.index];\n\n            // If the route matches the current one, then navigate to it\n            if (action.payload.name === currentRoute.name && !isPreviewAction(action)) {\n              route = currentRoute;\n            } else if (action.payload.pop) {\n              route = state.routes.findLast((route) => route.name === action.payload.name);\n            }\n          }\n\n          // START FORK\n          if (isPreviewAction(action) && !route) {\n            route = state.preloadedRoutes.find(\n              (route) => route.name === action.payload.name && id === route.key\n            );\n          }\n          // END FORK\n\n          if (!route) {\n            route = state.preloadedRoutes.find(\n              (route) =>\n                route.name === action.payload.name && id === getId?.({ params: route.params })\n            );\n          }\n\n          let params;\n\n          if (action.type === 'NAVIGATE' && action.payload.merge && route) {\n            params =\n              action.payload.params !== undefined ||\n              routeParamList[action.payload.name] !== undefined\n                ? {\n                    ...routeParamList[action.payload.name],\n                    ...route.params,\n                    ...action.payload.params,\n                  }\n                : route.params;\n          } else {\n            params =\n              routeParamList[action.payload.name] !== undefined\n                ? {\n                    ...routeParamList[action.payload.name],\n                    ...action.payload.params,\n                  }\n                : action.payload.params;\n          }\n\n          let routes: Route<string>[];\n\n          if (route) {\n            if (action.type === 'NAVIGATE' && action.payload.pop) {\n              routes = [];\n\n              // Get all routes until the matching one\n              for (const r of state.routes) {\n                if (r.key === route.key) {\n                  routes.push({\n                    ...route,\n                    path: action.payload.path !== undefined ? action.payload.path : route.path,\n                    params,\n                  });\n                  break;\n                }\n\n                routes.push(r);\n              }\n            } else {\n              // START FORK\n              // If there is an id, then filter out the existing route with the same id.\n              // THIS ACTION IS DANGEROUS. This can cause React Native Screens to freeze\n              if (id !== undefined) {\n                routes = state.routes.filter((r) => r.key !== route.key);\n              } else if (action.type === 'NAVIGATE' && state.routes.length > 0) {\n                // The navigation action should only replace the last route if it has the same name and path params.\n                const lastRoute = state.routes[state.routes.length - 1];\n                if (\n                  getSingularId(lastRoute.name, { params: lastRoute.params }) ===\n                  getSingularId(route.name, { params })\n                ) {\n                  routes = state.routes.slice(0, -1);\n                } else {\n                  routes = [...state.routes];\n                }\n              } else {\n                routes = [...state.routes];\n              }\n\n              // If the routes length is the same as the state routes length, then we are navigating to a new route.\n              // Otherwise we are replacing an existing route.\n              const key =\n                routes.length === state.routes.length && !isPreviewAction(action)\n                  ? `${action.payload.name}-${nanoid()}`\n                  : route.key;\n\n              routes.push({\n                ...route,\n                key,\n                path:\n                  action.type === 'NAVIGATE' && action.payload.path !== undefined\n                    ? action.payload.path\n                    : route.path,\n                params,\n              });\n\n              // routes = state.routes.filter((r) => r.key !== route.key);\n              // routes.push({\n              //   ...route,\n              //   path:\n              //     action.type === 'NAVIGATE' && action.payload.path !== undefined\n              //       ? action.payload.path\n              //       : route.path,\n              //   params,\n              // });\n              // END FORK\n            }\n          } else {\n            routes = [\n              ...state.routes,\n              {\n                key: `${action.payload.name}-${nanoid()}`,\n                name: action.payload.name,\n                path: action.type === 'NAVIGATE' ? action.payload.path : undefined,\n                params,\n              },\n            ];\n          }\n\n          // START FORK\n          // return filterSingular(\n          const result = {\n            ...state,\n            index: routes.length - 1,\n            preloadedRoutes: state.preloadedRoutes.filter(\n              (route) => routes[routes.length - 1].key !== route.key\n            ),\n            routes,\n          };\n\n          if (actionSingularOptions) {\n            return filterSingular(result, getId);\n          }\n\n          return result;\n          // return {\n          //   ...state,\n          //   index: routes.length - 1,\n          //   preloadedRoutes: state.preloadedRoutes.filter(\n          //     (route) => routes[routes.length - 1].key !== route.key\n          //   ),\n          //   routes,\n          // };\n          // END FORK\n        }\n        case 'PRELOAD': {\n          // START FORK\n          // This will be the case for example for protected route\n          if (!state.routeNames.includes(action.payload.name)) {\n            return null;\n          }\n          // END FORK\n          const getId = options.routeGetIdList[action.payload.name];\n          const id = getId?.({ params: action.payload.params });\n\n          let route: Route<string> | undefined;\n\n          if (id !== undefined) {\n            route = state.routes.find(\n              (route) =>\n                route.name === action.payload.name && id === getId?.({ params: route.params })\n            );\n          }\n\n          if (route) {\n            return {\n              ...state,\n              routes: state.routes.map((r) => {\n                if (r.key !== route?.key) {\n                  return r;\n                }\n                return {\n                  ...r,\n                  params:\n                    routeParamList[action.payload.name] !== undefined\n                      ? {\n                          ...routeParamList[action.payload.name],\n                          ...action.payload.params,\n                        }\n                      : action.payload.params,\n                };\n              }),\n            };\n          } else {\n            // START FORK\n            const currentPreloadedRoute: (typeof state)['preloadedRoutes'][number] = {\n              key: `${action.payload.name}-${nanoid()}`,\n              name: action.payload.name,\n              params:\n                routeParamList[action.payload.name] !== undefined\n                  ? {\n                      ...routeParamList[action.payload.name],\n                      ...action.payload.params,\n                    }\n                  : action.payload.params,\n            };\n            // END FORK\n            return {\n              ...state,\n              // START FORK\n              // Adding the current preloaded route to the beginning of the preloadedRoutes array\n              // This ensures that the preloaded route will be the next one after the visible route\n              // and when navigation will happen, there will be no reshuffling\n              // This is a workaround for the link preview navigation issue, when screen would freeze after navigation from native side\n              // and reshuffling from react-navigation\n              preloadedRoutes: [currentPreloadedRoute].concat(\n                state.preloadedRoutes.filter(\n                  (r) => r.name !== action.payload.name || id !== getId?.({ params: r.params })\n                )\n              ),\n              // preloadedRoutes: state.preloadedRoutes\n              //   .filter(\n              //     (r) =>\n              //       r.name !== action.payload.name ||\n              //       id !== getId?.({ params: r.params })\n              //   )\n              //   .concat({\n              //     key: `${action.payload.name}-${nanoid()}`,\n              //     name: action.payload.name,\n              //     params:\n              //       routeParamList[action.payload.name] !== undefined\n              //         ? {\n              //             ...routeParamList[action.payload.name],\n              //             ...action.payload.params,\n              //           }\n              //         : action.payload.params,\n              //   }),\n              // END FORK\n            };\n          }\n        }\n        default: {\n          return original.getStateForAction(state, action, options);\n        }\n      }\n    },\n  };\n};\n\nfunction getActionSingularIdFn(\n  actionGetId: SingularOptions | undefined,\n  name: string\n): GetId | undefined {\n  if (typeof actionGetId === 'function') {\n    return (options) => actionGetId(name, options.params ?? {});\n  } else if (actionGetId === true) {\n    return (options) => getSingularId(name, options);\n  }\n\n  return undefined;\n}\n\n/**\n * If there is a dynamic singular on an action, then we need to filter the state to only have singular screens.\n * As multiples may have been added before we did the singular navigation.\n */\nfunction filterSingular<\n  T extends\n    | StackNavigationState<ParamListBase>\n    | PartialState<StackNavigationState<ParamListBase>>\n    | null,\n>(state: T, getId?: GetId): T {\n  if (!state) {\n    return state;\n  }\n\n  if (!state.routes) {\n    return state;\n  }\n\n  const currentIndex = state.index || state.routes.length - 1;\n  const current = state.routes[currentIndex];\n  const name = current.name;\n\n  const id = getId?.({ params: current.params });\n\n  if (!id) {\n    return state;\n  }\n\n  // TypeScript needs a type assertion here for the filter to work.\n  let routes = state.routes as PartialRoute<Route<string, object | undefined>>[];\n  routes = routes.filter((route, index) => {\n    // If the route is the current route, keep it.\n    if (index === currentIndex) {\n      return true;\n    }\n\n    // Remove all other routes with the same name and id.\n    return name !== route.name || id !== getId?.({ params: route.params });\n  });\n\n  return {\n    ...state,\n    index: routes.length - 1,\n    routes,\n  };\n}\n\nconst Stack = Object.assign(\n  (props: ComponentProps<typeof RNStack>) => {\n    const { isStackAnimationDisabled } = useLinkPreviewContext();\n\n    const screenOptions = useMemo(() => {\n      const condition = isStackAnimationDisabled ? () => true : shouldDisableAnimationBasedOnParams;\n\n      return disableAnimationInScreenOptions(props.screenOptions, condition);\n    }, [props.screenOptions, isStackAnimationDisabled]);\n\n    return (\n      <RNStack {...props} screenOptions={screenOptions} UNSTABLE_router={stackRouterOverride} />\n    );\n  },\n  {\n    Screen: RNStack.Screen as (\n      props: ComponentProps<typeof RNStack.Screen> & { singular?: boolean }\n    ) => null,\n    Protected,\n  }\n);\n\ntype NativeStackScreenOptions = ComponentProps<typeof RNStack>['screenOptions'];\n\nfunction disableAnimationInScreenOptions(\n  options: NativeStackScreenOptions | undefined,\n  condition: (route: RouteProp<ParamListBase, string>) => boolean\n): NativeStackScreenOptions {\n  if (options && typeof options === 'function') {\n    return (props) => {\n      const oldOptions = options(props);\n      if (condition(props.route)) {\n        return {\n          ...oldOptions,\n          animation: 'none',\n        };\n      }\n      return oldOptions ?? {};\n    };\n  }\n  return (props) => {\n    if (condition(props.route)) {\n      return {\n        ...(options ?? {}),\n        animation: 'none',\n      };\n    }\n    return options ?? {};\n  };\n}\n\nfunction shouldDisableAnimationBasedOnParams(route: RouteProp<ParamListBase, string>): boolean {\n  const expoParams = getInternalExpoRouterParams(route.params);\n  return !!expoParams.__internal_expo_router_no_animation;\n}\n\nexport default Stack;\n\nexport const StackRouter: typeof RNStackRouter = (options) => {\n  const router = RNStackRouter(options);\n  return {\n    ...router,\n    ...stackRouterOverride(router),\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}