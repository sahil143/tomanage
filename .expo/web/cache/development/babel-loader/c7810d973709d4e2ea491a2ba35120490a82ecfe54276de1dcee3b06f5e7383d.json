{"ast":null,"code":"\"use strict\";\n'use client';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NativeTabTrigger = void 0;\nexports.convertTabPropsToOptions = convertTabPropsToOptions;\nexports.appendIconOptions = appendIconOptions;\nexports.isNativeTabTrigger = isNativeTabTrigger;\nconst native_1 = require(\"@react-navigation/native\");\nconst react_1 = require(\"react\");\nconst NativeTabsTriggerTabBar_1 = require(\"./NativeTabsTriggerTabBar\");\nconst utils_1 = require(\"./utils\");\nconst PreviewRouteContext_1 = require(\"../../link/preview/PreviewRouteContext\");\nconst useSafeLayoutEffect_1 = require(\"../../views/useSafeLayoutEffect\");\nconst elements_1 = require(\"../common/elements\");\nfunction NativeTabTriggerImpl(props) {\n  const route = (0, native_1.useRoute)();\n  const navigation = (0, native_1.useNavigation)();\n  const isFocused = navigation.isFocused();\n  const isInPreview = (0, PreviewRouteContext_1.useIsPreview)();\n  (0, useSafeLayoutEffect_1.useSafeLayoutEffect)(() => {\n    if (isFocused && !isInPreview) {\n      if (navigation.getState()?.type !== 'tab') {\n        throw new Error(`Trigger component can only be used in the tab screen. Current route: ${route.name}`);\n      }\n      const options = convertTabPropsToOptions(props, true);\n      navigation.setOptions(options);\n    }\n  }, [isFocused, props, isInPreview]);\n  return null;\n}\nexports.NativeTabTrigger = Object.assign(NativeTabTriggerImpl, {\n  TabBar: NativeTabsTriggerTabBar_1.NativeTabsTriggerTabBar\n});\nfunction convertTabPropsToOptions({\n  options,\n  hidden,\n  children,\n  role,\n  disablePopToTop,\n  disableScrollToTop\n}, isDynamic = false) {\n  const initialOptions = isDynamic ? Object.assign({}, options) : Object.assign({}, options, {\n    hidden: !!hidden,\n    specialEffects: {\n      repeatedTabSelection: {\n        popToRoot: !disablePopToTop,\n        scrollToTop: !disableScrollToTop\n      }\n    },\n    role: role ?? options?.role\n  });\n  const allowedChildren = (0, utils_1.filterAllowedChildrenElements)(children, [elements_1.Badge, elements_1.Label, elements_1.Icon, NativeTabsTriggerTabBar_1.NativeTabsTriggerTabBar]);\n  return allowedChildren.reduce((acc, child) => {\n    if ((0, utils_1.isChildOfType)(child, elements_1.Badge)) {\n      appendBadgeOptions(acc, child.props);\n    } else if ((0, utils_1.isChildOfType)(child, elements_1.Label)) {\n      appendLabelOptions(acc, child.props);\n    } else if ((0, utils_1.isChildOfType)(child, elements_1.Icon)) {\n      appendIconOptions(acc, child.props);\n    } else if ((0, utils_1.isChildOfType)(child, NativeTabsTriggerTabBar_1.NativeTabsTriggerTabBar)) {\n      appendTabBarOptions(acc, child.props);\n    }\n    return acc;\n  }, Object.assign({}, initialOptions));\n}\nfunction appendBadgeOptions(options, props) {\n  if (props.children) {\n    options.badgeValue = String(props.children);\n    options.selectedBadgeBackgroundColor = props.selectedBackgroundColor;\n  } else if (!props.hidden) {\n    options.badgeValue = ' ';\n  }\n}\nfunction appendLabelOptions(options, props) {\n  if (props.hidden) {\n    options.title = '';\n  } else {\n    options.title = props.children;\n    if (props.selectedStyle) {\n      options.selectedLabelStyle = props.selectedStyle;\n    }\n  }\n}\nfunction appendIconOptions(options, props) {\n  if ('src' in props && props.src) {\n    const icon = convertIconSrcToIconOption(props);\n    options.icon = icon?.icon;\n    options.selectedIcon = icon?.selectedIcon;\n  } else if ('sf' in props && false) {\n    if (typeof props.sf === 'string') {\n      options.icon = props.sf ? {\n        sf: props.sf\n      } : undefined;\n      options.selectedIcon = undefined;\n    } else if (props.sf) {\n      options.icon = props.sf.default ? {\n        sf: props.sf.default\n      } : undefined;\n      options.selectedIcon = props.sf.selected ? {\n        sf: props.sf.selected\n      } : undefined;\n    }\n  } else if ('androidSrc' in props && false) {\n    const icon = convertIconSrcToIconOption({\n      src: props.androidSrc\n    });\n    options.icon = icon?.icon;\n    options.selectedIcon = icon?.selectedIcon;\n  } else if ('drawable' in props && false) {\n    options.icon = {\n      drawable: props.drawable\n    };\n    options.selectedIcon = undefined;\n  }\n  if (props.selectedColor) {\n    options.selectedIconColor = props.selectedColor;\n  }\n}\nfunction convertIconSrcToIconOption(icon) {\n  if (icon && icon.src) {\n    const {\n      defaultIcon,\n      selected\n    } = typeof icon.src === 'object' && 'selected' in icon.src ? {\n      defaultIcon: icon.src.default,\n      selected: icon.src.selected\n    } : {\n      defaultIcon: icon.src\n    };\n    const options = {};\n    options.icon = convertSrcOrComponentToSrc(defaultIcon);\n    options.selectedIcon = convertSrcOrComponentToSrc(selected);\n    return options;\n  }\n  return undefined;\n}\nfunction convertSrcOrComponentToSrc(src) {\n  if (src) {\n    if ((0, react_1.isValidElement)(src)) {\n      if (src.type === elements_1.VectorIcon) {\n        const props = src.props;\n        return {\n          src: props.family.getImageSource(props.name, 24, 'white')\n        };\n      } else {\n        console.warn('Only VectorIcon is supported as a React element in Icon.src');\n      }\n    } else {\n      return {\n        src\n      };\n    }\n  }\n  return undefined;\n}\nfunction appendTabBarOptions(options, props) {\n  const {\n    backgroundColor,\n    blurEffect,\n    iconColor,\n    disableTransparentOnScrollEdge,\n    badgeBackgroundColor,\n    badgeTextColor,\n    indicatorColor,\n    labelStyle,\n    shadowColor\n  } = props;\n  if (backgroundColor) {\n    options.backgroundColor = backgroundColor;\n  }\n  if (true) {\n    if (blurEffect) {\n      options.blurEffect = blurEffect;\n    }\n    if (shadowColor) {\n      options.shadowColor = shadowColor;\n    }\n    if (iconColor) {\n      options.iconColor = iconColor;\n    }\n    if (disableTransparentOnScrollEdge !== undefined) {\n      options.disableTransparentOnScrollEdge = disableTransparentOnScrollEdge;\n    }\n    if (badgeBackgroundColor) {\n      options.badgeBackgroundColor = badgeBackgroundColor;\n    }\n    if (badgeTextColor) {\n      options.badgeTextColor = badgeTextColor;\n    }\n    if (indicatorColor) {\n      options.indicatorColor = indicatorColor;\n    }\n    if (labelStyle) {\n      options.labelStyle = labelStyle;\n    }\n  }\n}\nfunction isNativeTabTrigger(child, contextKey) {\n  if ((0, react_1.isValidElement)(child) && child && child.type === exports.NativeTabTrigger) {\n    if (typeof child.props === 'object' && child.props && 'name' in child.props && !child.props.name) {\n      throw new Error(`<Trigger /> component in \\`default export\\` at \\`app${contextKey}/_layout\\` must have a \\`name\\` prop when used as a child of a Layout Route.`);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      if (['component', 'getComponent'].some(key => child.props && typeof child.props === 'object' && key in child.props)) {\n        throw new Error(`<Trigger /> component in \\`default export\\` at \\`app${contextKey}/_layout\\` must not have a \\`component\\` or \\`getComponent\\` prop when used as a child of a Layout Route`);\n      }\n    }\n    return true;\n  }\n  return false;\n}","map":{"version":3,"names":["exports","convertTabPropsToOptions","appendIconOptions","isNativeTabTrigger","native_1","require","react_1","NativeTabsTriggerTabBar_1","utils_1","PreviewRouteContext_1","useSafeLayoutEffect_1","elements_1","NativeTabTriggerImpl","props","route","useRoute","navigation","useNavigation","isFocused","isInPreview","useIsPreview","useSafeLayoutEffect","getState","type","Error","name","options","setOptions","NativeTabTrigger","Object","assign","TabBar","NativeTabsTriggerTabBar","hidden","children","role","disablePopToTop","disableScrollToTop","isDynamic","initialOptions","specialEffects","repeatedTabSelection","popToRoot","scrollToTop","allowedChildren","filterAllowedChildrenElements","Badge","Label","Icon","reduce","acc","child","isChildOfType","appendBadgeOptions","appendLabelOptions","appendTabBarOptions","badgeValue","String","selectedBadgeBackgroundColor","selectedBackgroundColor","title","selectedStyle","selectedLabelStyle","src","icon","convertIconSrcToIconOption","selectedIcon","sf","undefined","default","selected","androidSrc","drawable","selectedColor","selectedIconColor","defaultIcon","convertSrcOrComponentToSrc","isValidElement","VectorIcon","family","getImageSource","console","warn","backgroundColor","blurEffect","iconColor","disableTransparentOnScrollEdge","badgeBackgroundColor","badgeTextColor","indicatorColor","labelStyle","shadowColor","contextKey","process","env","NODE_ENV","some","key"],"sources":["/Users/sbudhwar/workspace/github/tomanage/node_modules/expo-router/src/native-tabs/NativeBottomTabs/NativeTabTrigger.tsx"],"sourcesContent":["'use client';\n\nimport { useNavigation, useRoute } from '@react-navigation/native';\nimport { isValidElement, type ReactElement, type ReactNode } from 'react';\nimport type { ImageSourcePropType } from 'react-native';\n\nimport { NativeTabsTriggerTabBar } from './NativeTabsTriggerTabBar';\nimport type {\n  ExtendedNativeTabOptions,\n  NativeTabOptions,\n  NativeTabsTriggerTabBarProps,\n  NativeTabTriggerProps,\n} from './types';\nimport { filterAllowedChildrenElements, isChildOfType } from './utils';\nimport { useIsPreview } from '../../link/preview/PreviewRouteContext';\nimport { useSafeLayoutEffect } from '../../views/useSafeLayoutEffect';\nimport {\n  Icon,\n  Badge,\n  Label,\n  type LabelProps,\n  type IconProps,\n  type BadgeProps,\n  type SourceIconCombination,\n  VectorIcon,\n  type VectorIconProps,\n} from '../common/elements';\n\n/**\n * The component used to customize the native tab options both in the _layout file and from the tab screen.\n *\n * When used in the _layout file, you need to provide a `name` prop.\n * When used in the tab screen, the `name` prop takes no effect.\n *\n * @example\n * ```tsx\n * // In _layout file\n * import { NativeTabs } from 'expo-router/unstable-native-tabs';\n *\n * export default function Layout() {\n *   return (\n *     <NativeTabs>\n *       <NativeTabs.Trigger name=\"home\" />\n *       <NativeTabs.Trigger name=\"settings\" />\n *     </NativeTabs>\n *   );\n * }\n * ```\n *\n * @example\n * ```tsx\n * // In a tab screen\n * import { NativeTabs } from 'expo-router/unstable-native-tabs';\n *\n * export default function HomeScreen() {\n *   return (\n *     <View>\n *       <NativeTabs.Trigger>\n *         <Label>Home</Label>\n *       </NativeTabs.Trigger>\n *       <Text>This is home screen!</Text>\n *     </View>\n *   );\n * }\n * ```\n *\n * > **Note:** You can use the alias `NativeTabs.Trigger` for this component.\n */\nfunction NativeTabTriggerImpl(props: NativeTabTriggerProps) {\n  const route = useRoute();\n  const navigation = useNavigation();\n  const isFocused = navigation.isFocused();\n  const isInPreview = useIsPreview();\n\n  useSafeLayoutEffect(() => {\n    // This will cause the tab to update only when it is focused.\n    // As long as all tabs are loaded at the start, we don't need this check.\n    // It is here to ensure similar behavior to stack\n    if (isFocused && !isInPreview) {\n      if (navigation.getState()?.type !== 'tab') {\n        throw new Error(\n          `Trigger component can only be used in the tab screen. Current route: ${route.name}`\n        );\n      }\n      const options = convertTabPropsToOptions(props, true);\n      navigation.setOptions(options);\n    }\n  }, [isFocused, props, isInPreview]);\n\n  return null;\n}\n\nexport const NativeTabTrigger = Object.assign(NativeTabTriggerImpl, {\n  TabBar: NativeTabsTriggerTabBar,\n});\n\nexport function convertTabPropsToOptions(\n  { options, hidden, children, role, disablePopToTop, disableScrollToTop }: NativeTabTriggerProps,\n  isDynamic: boolean = false\n) {\n  const initialOptions: ExtendedNativeTabOptions = isDynamic\n    ? { ...options }\n    : {\n        ...options,\n        hidden: !!hidden,\n        specialEffects: {\n          repeatedTabSelection: {\n            popToRoot: !disablePopToTop,\n            scrollToTop: !disableScrollToTop,\n          },\n        },\n        role: role ?? options?.role,\n      };\n  const allowedChildren = filterAllowedChildrenElements(children, [\n    Badge,\n    Label,\n    Icon,\n    NativeTabsTriggerTabBar,\n  ]);\n  return allowedChildren.reduce<ExtendedNativeTabOptions>(\n    (acc, child) => {\n      if (isChildOfType(child, Badge)) {\n        appendBadgeOptions(acc, child.props);\n      } else if (isChildOfType(child, Label)) {\n        appendLabelOptions(acc, child.props);\n      } else if (isChildOfType(child, Icon)) {\n        appendIconOptions(acc, child.props);\n      } else if (isChildOfType(child, NativeTabsTriggerTabBar)) {\n        appendTabBarOptions(acc, child.props);\n      }\n      return acc;\n    },\n    { ...initialOptions }\n  );\n}\n\nfunction appendBadgeOptions(options: ExtendedNativeTabOptions, props: BadgeProps) {\n  if (props.children) {\n    options.badgeValue = String(props.children);\n    options.selectedBadgeBackgroundColor = props.selectedBackgroundColor;\n  } else if (!props.hidden) {\n    // If no value is provided, we set it to a space to show the badge\n    // Otherwise, the `react-native-screens` will interpret it as a hidden badge\n    // https://github.com/software-mansion/react-native-screens/blob/b4358fd95dd0736fc54df6bb97f210dc89edf24c/ios/bottom-tabs/RNSBottomTabsScreenComponentView.mm#L172\n    options.badgeValue = ' ';\n  }\n}\n\nfunction appendLabelOptions(options: ExtendedNativeTabOptions, props: LabelProps) {\n  if (props.hidden) {\n    options.title = '';\n  } else {\n    options.title = props.children;\n    if (props.selectedStyle) {\n      options.selectedLabelStyle = props.selectedStyle;\n    }\n  }\n}\n\nexport function appendIconOptions(options: ExtendedNativeTabOptions, props: IconProps) {\n  if ('src' in props && props.src) {\n    const icon = convertIconSrcToIconOption(props);\n    options.icon = icon?.icon;\n    options.selectedIcon = icon?.selectedIcon;\n  } else if ('sf' in props && process.env.EXPO_OS === 'ios') {\n    if (typeof props.sf === 'string') {\n      options.icon = props.sf\n        ? {\n            sf: props.sf,\n          }\n        : undefined;\n      options.selectedIcon = undefined;\n    } else if (props.sf) {\n      options.icon = props.sf.default\n        ? {\n            sf: props.sf.default,\n          }\n        : undefined;\n      options.selectedIcon = props.sf.selected\n        ? {\n            sf: props.sf.selected,\n          }\n        : undefined;\n    }\n  } else if ('androidSrc' in props && process.env.EXPO_OS === 'android') {\n    const icon = convertIconSrcToIconOption({ src: props.androidSrc });\n    options.icon = icon?.icon;\n    options.selectedIcon = icon?.selectedIcon;\n  } else if ('drawable' in props && process.env.EXPO_OS === 'android') {\n    options.icon = { drawable: props.drawable };\n    options.selectedIcon = undefined;\n  }\n  if (props.selectedColor) {\n    options.selectedIconColor = props.selectedColor;\n  }\n}\n\nfunction convertIconSrcToIconOption(\n  icon: SourceIconCombination | undefined\n): Pick<NativeTabOptions, 'icon' | 'selectedIcon'> | undefined {\n  if (icon && icon.src) {\n    const { defaultIcon, selected } =\n      typeof icon.src === 'object' && 'selected' in icon.src\n        ? { defaultIcon: icon.src.default, selected: icon.src.selected }\n        : { defaultIcon: icon.src };\n\n    const options: Pick<NativeTabOptions, 'icon' | 'selectedIcon'> = {};\n    options.icon = convertSrcOrComponentToSrc(defaultIcon);\n    options.selectedIcon = convertSrcOrComponentToSrc(selected);\n    return options;\n  }\n\n  return undefined;\n}\n\nfunction convertSrcOrComponentToSrc(src: ImageSourcePropType | ReactElement | undefined) {\n  if (src) {\n    if (isValidElement(src)) {\n      if (src.type === VectorIcon) {\n        const props = src.props as VectorIconProps<string>;\n        return { src: props.family.getImageSource(props.name, 24, 'white') };\n      } else {\n        console.warn('Only VectorIcon is supported as a React element in Icon.src');\n      }\n    } else {\n      return { src };\n    }\n  }\n  return undefined;\n}\n\nfunction appendTabBarOptions(\n  options: ExtendedNativeTabOptions,\n  props: NativeTabsTriggerTabBarProps\n) {\n  const {\n    backgroundColor,\n    blurEffect,\n    iconColor,\n    disableTransparentOnScrollEdge,\n    badgeBackgroundColor,\n    badgeTextColor,\n    indicatorColor,\n    labelStyle,\n    shadowColor,\n  } = props;\n\n  if (backgroundColor) {\n    options.backgroundColor = backgroundColor;\n  }\n  // We need better native integration of this on Android\n  // Simulating from JS side creates ugly transitions\n  if (process.env.EXPO_OS !== 'android') {\n    if (blurEffect) {\n      options.blurEffect = blurEffect;\n    }\n    if (shadowColor) {\n      options.shadowColor = shadowColor;\n    }\n    if (iconColor) {\n      options.iconColor = iconColor;\n    }\n    if (disableTransparentOnScrollEdge !== undefined) {\n      options.disableTransparentOnScrollEdge = disableTransparentOnScrollEdge;\n    }\n    if (badgeBackgroundColor) {\n      options.badgeBackgroundColor = badgeBackgroundColor;\n    }\n    if (badgeTextColor) {\n      options.badgeTextColor = badgeTextColor;\n    }\n    if (indicatorColor) {\n      options.indicatorColor = indicatorColor;\n    }\n    if (labelStyle) {\n      options.labelStyle = labelStyle;\n    }\n  }\n}\n\nexport function isNativeTabTrigger(\n  child: ReactNode,\n  contextKey?: string\n): child is ReactElement<NativeTabTriggerProps & { name: string }> {\n  if (isValidElement(child) && child && child.type === NativeTabTrigger) {\n    if (\n      typeof child.props === 'object' &&\n      child.props &&\n      'name' in child.props &&\n      !child.props.name\n    ) {\n      throw new Error(\n        `<Trigger /> component in \\`default export\\` at \\`app${contextKey}/_layout\\` must have a \\`name\\` prop when used as a child of a Layout Route.`\n      );\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (\n        ['component', 'getComponent'].some(\n          (key) => child.props && typeof child.props === 'object' && key in child.props\n        )\n      ) {\n        throw new Error(\n          `<Trigger /> component in \\`default export\\` at \\`app${contextKey}/_layout\\` must not have a \\`component\\` or \\`getComponent\\` prop when used as a child of a Layout Route`\n        );\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}